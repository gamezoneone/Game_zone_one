<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Gates of Olympus - Slot Demo</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&family=Press+Start+2P&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
        /* Neon Theme Colors (dapat disesuaikan untuk tema Zeus) */
        :root {
            --zeus-bg-dark: #1a0f30; /* Darker purple/blue for background */
            --zeus-bg-light: #3a1f60; /* Lighter purple */
            --zeus-gold: #FFD700; /* Gold color */
            --zeus-blue: #00BFFF; /* Deep Sky Blue */
            --zeus-purple: #8A2BE2; /* Blue Violet */
            --zeus-red: #DC143C; /* Crimson */
            --text-primary: #f0f0f0;
            --text-secondary: #cccccc;
            --border-glow-gold: #FFD700;
            --button-primary: linear-gradient(45deg, #00BFFF, #8A2BE2);
            --button-hover: linear-gradient(45deg, #8A2BE2, #00BFFF);
            --glow-sm: 0 0 5px;
            --glow-md: 0 0 10px;
            --glow-lg: 0 0 20px;
        }

       body {
            font-family: 'Share Tech Mono', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Mengatur konten ke atas */
            min-height: 100vh;
            background-image: url('https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/zaus//images%20(3).jpeg'); /* Placeholder Zeus BG */
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            color: var(--text-primary);
            margin: 0;
            padding: 10px;
            overflow: hidden;
            box-sizing: border-box;
        }

    h1 {
      background: linear-gradient(45deg, var(--zeus-gold), var(--zeus-blue), var(--zeus-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-size: 2em;
      margin-top: 10px;
      margin-bottom: 15px;
      text-shadow: var(--glow-md) var(--zeus-gold);
      text-align: center;
      padding: 5px 15px;
      border: 2px solid var(--zeus-purple);
      border-radius: 12px;
      box-shadow: var(--glow-md) var(--zeus-blue);
      animation: zeusPulse 2s infinite alternate;
      letter-spacing: 1px;
    }

    @keyframes zeusPulse {
      0% { box-shadow: var(--glow-md) var(--zeus-blue); }
      100% { box-shadow: var(--glow-md) var(--zeus-purple); }
    }

    hr {
      border: none;
      border-top: 1px dashed var(--zeus-gold);
      margin-top: 8px;
    }

    .slot-frame {
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 15px;
      box-shadow: var(--glow-md) var(--zeus-blue);
      border: 2px solid var(--zeus-purple);
      position: relative;
      overflow: hidden; /* Penting untuk animasi jatuh */
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .slot-grid {
      display: grid;
      grid-template-columns: repeat(6, min(65px, 15vw)); /* Gates of Olympus is 6x5 */
      grid-template-rows: repeat(5, min(65px, 15vw));
      gap: 5px;
      justify-content: center;
      border: 0px solid var(--zeus-gold);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: inset 0 0 10px rgba(0,191,255,0.3); /* Blue glow inside */
      position: relative; /* Untuk positioning tile */
    }

    .tile {
      background: #222;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: min(35px, 7vw);
      font-weight: bold;
      color: var(--zeus-gold);
      box-shadow: inset 0 0 3px rgba(255, 215, 0, 0.2), 0 0 5px rgba(255, 215, 0, 0.3);
      transition: transform 0.1s linear, box-shadow 0.3s ease;
      overflow: hidden;
      border: 1px solid rgba(255, 215, 0, 0.1);
      position: relative;
      /* Animasi Jatuh */
      transform: translateY(0);
      transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.4, 1.2), opacity 0.3s ease-out; /* Tambah opacity transition */
      z-index: 1; /* Default z-index */
    }

    .tile.falling {
        transition: none; /* Disable transition during fall preparation */
        transform: translateY(-100vh); /* Start far above */
    }

    .tile img {
      max-width: 90%;
      max-height: 90%;
      object-fit: contain;
      display: block;
      filter: drop-shadow(0 0 5px rgba(0, 191, 255, 0.8)); /* Blue drop shadow for Zeus theme */
    }

    .tile.break {
      animation: breakAnim 0.5s forwards;
      z-index: 2; /* Agar di atas tile lain saat pecah */
    }
    @keyframes breakAnim {
      0% { transform: scale(1); opacity: 1; border-color: var(--zeus-red); }
      100% { transform: scale(0.1); opacity: 0; }
    }

    .popup {
      position: fixed;
      top: 80%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: var(--zeus-gold);
      padding: 15px 25px;
      border: 2px solid var(--zeus-gold);
      border-radius: 10px;
      font-size: 1.2em;
      box-shadow: var(--glow-md) var(--zeus-gold);
      z-index: 9999;
      display: none;
      text-align: center;
      text-transform: uppercase;
      font-weight: 600;
    }

    .controls-container {
        width: 100%;
        max-width: 500px; /* Lebar kontrol */
        display: flex;
        flex-wrap: wrap;
        justify-content: space-around;
        align-items: center;
        margin-top: 15px;
        padding: 0 10px;
        box-sizing: border-box;
    }

    .info-box {
        background-color: var(--zeus-bg-dark);
        border-radius: 10px;
        box-shadow: 0 0 15px var(--border-glow-gold), inset 0 0 5px var(--border-glow-gold);
        padding: 8px 15px;
        text-align: center;
        font-size: 0.9em;
        color: var(--text-primary);
        border: 2px solid var(--zeus-blue);
        margin: 5px;
        flex-grow: 1;
        white-space: nowrap;
    }
    .info-box.balance-box { border-color: var(--zeus-gold); color: var(--zeus-gold); }
    .info-box.bet-box { border-color: var(--zeus-purple); color: var(--zeus-purple); }
    .info-box.freespin-box { border-color: var(--zeus-red); color: var(--zeus-red); }

    .multiplier {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.0);
      padding: 0px 0px;
      border-radius: 15px;
      color: var(--zeus-gold); /* Multiplier color */
      font-size: 2em;
      font-weight: bold;
      border: 0px solid var(--zeus-gold);
      box-shadow: ;
      transition: transform 0.2s ease-out;
      z-index: 5;
    }

    .multiplier.zoom {
      animation: multiplierZoom 0.3s ease forwards;
    }

    @keyframes multiplierZoom {
      0% { transform: scale(1); }
      50% { transform: scale(1.5); text-shadow: var(--glow-md) var(--zeus-gold); }
      100% { transform: scale(1); }
    }

    .spin-button {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--zeus-red); /* Spin button color */
      border: 3px solid var(--zeus-gold);
      border-radius: 50%;
      width: 80px;
      height: 80px;
      font-size: 1.1em;
      font-weight: bold;
      color: #FFF;
      text-shadow: 0 0 8px #FFF, 0 0 15px var(--zeus-gold);
      box-shadow: var(--glow-md) var(--zeus-red);
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 20;
    }

    .spin-button:hover {
      transform: translateX(-50%) scale(1.05);
      box-shadow: var(--glow-md) var(--zeus-blue), var(--glow-md) var(--zeus-gold);
      background: linear-gradient(45deg, var(--zeus-red), var(--zeus-purple));
    }

    .spin-button:active {
      transform: translateX(-50%) scale(0.95);
      box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.5);
    }

    .spin-button:disabled {
      background: #555;
      border-color: #888;
      color: #AAA;
      box-shadow: none;
      cursor: not-allowed;
    }

    .bet-buttons-container {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 10px;
        width: 100%;
        max-width: 400px;
    }

    .bet-buttons-container button {
      padding: 8px 18px;
      background: rgba(0, 0, 0, 0.7);
      color: var(--zeus-blue);
      border: 2px solid var(--zeus-blue);
      border-radius: 25px;
      font-size: 0.9em;
      font-weight: bold;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow: 0 0 8px rgba(0, 0, 255, 0.3);
      transition: all 0.2s ease;
    }

    .bet-buttons-container button:hover {
      background: rgba(0, 0, 0, 0.9);
      box-shadow: var(--glow-md) var(--zeus-blue);
    }

    .bet-buttons-container button:active {
      transform: scale(0.97);
    }

    /* Specific bet button colors */
    #betMinus { border-color: var(--zeus-purple); color: var(--zeus-purple); }
    #betPlus { border-color: var(--zeus-red); color: var(--zeus-red); }
    #minBetBtn, #maxBetBtn { border-color: var(--zeus-gold); color: var(--zeus-gold); }

    /* Special Symbol styling (can be applied to Orb/Scatter as needed) */
    .tile.special-symbol { /* For Orb multipliers */
      border: 2px solid var(--zeus-gold);
      box-shadow: 0 0 10px var(--zeus-gold), inset 0 0 5px var(--zeus-gold);
      animation: pulseSpecial 1.2s infinite alternate;
    }

    @keyframes pulseSpecial {
      0% { transform: scale(1); box-shadow: 0 0 10px var(--zeus-gold), inset 0 0 5px var(--zeus-gold); }
      50% { transform: scale(1.02); box-shadow: 0 0 18px var(--zeus-gold), inset 0 0 8px var(--zeus-gold); }
      100% { transform: scale(1); box-shadow: 0 0 10px var(--zeus-gold), inset 0 0 5px var(--zeus-gold); }
    }

    .tile.scatter-symbol { /* For Zeus Scatter */
      border: 2px solid var(--zeus-blue);
      box-shadow: 0 0 10px var(--zeus-blue), inset 0 0 5px var(--zeus-blue);
      animation: pulseScatter 1.2s infinite alternate;
    }

    @keyframes pulseScatter {
      0% { transform: scale(1); box-shadow: 0 0 10px var(--zeus-blue), inset 0 0 5px var(--zeus-blue); }
      50% { transform: scale(1.02); box-shadow: 0 0 18px var(--zeus-blue), inset 0 0 8px var(--zeus-blue); }
      100% { transform: scale(1); box-shadow: 0 0 10px var(--zeus-blue), inset 0 0 5px var(--zeus-blue); }
    }

    /* Win Animation Overlay */
    .win-animation-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.4s ease, visibility 0.4s ease;
    }

    .win-animation-content {
        background: linear-gradient(45deg, var(--zeus-gold), var(--zeus-blue), var(--zeus-purple));
        padding: 30px 40px;
        border-radius: 20px;
        box-shadow: var(--glow-lg) var(--zeus-gold);
        text-align: center;
        transform: scale(0.7);
        opacity: 0;
        animation: winPopIn 0.8s forwards ease-out;
        border: 3px solid var(--zeus-gold);
    }

    @keyframes winPopIn {
        0% { transform: scale(0.5); opacity: 0; }
        70% { transform: scale(1.05); opacity: 1; }
        100% { transform: scale(1); opacity: 1; }
    }

    .win-animation-content h2 {
        font-size: 2.5em;
        color: #FFF;
        margin-bottom: 15px;
        text-shadow: var(--glow-md) var(--zeus-red);
        text-transform: uppercase;
        letter-spacing: 2px;
        font-weight: 800;
    }

    .win-animation-content p {
        font-size: 2em;
        color: var(--zeus-gold);
        font-weight: bold;
        text-shadow: var(--glow-md) var(--zeus-gold);
        letter-spacing: 1px;
    }

    marquee {
        width: 100%;
        background: rgba(0, 0, 0, 0.5);
        color: var(--zeus-gold);
        padding: 5px 0;
        margin-bottom: 10px;
        font-size: 0.9em;
        border-top: 1px solid var(--zeus-gold);
        border-bottom: 1px solid var(--zeus-gold);
        box-shadow: 0 0 10px rgba(255,215,0,0.3);
    }

    /* Media queries untuk responsivitas */
    @media (max-width: 768px) {
        body { padding: 5px; }
        h1 { font-size: 1.5em; margin-bottom: 10px; }
        .slot-frame { padding: 5px; }
        .slot-grid {
            grid-template-columns: repeat(6, min(50px, 15vw));
            grid-template-rows: repeat(5, min(50px, 15vw));
            gap: 2px;
        }
        .tile { font-size: min(25px, 6vw); border-radius: 4px; }
        .tile img { max-width: 80%; max-height: 80%; } /* Sesuaikan ukuran gambar agar ada ruang teks */
        .multiplier { font-size: 1.5em; padding: 5px 10px; top: 5px; right: 5px; }
        .spin-button { width: 60px; height: 60px; font-size: 0.9em; bottom: 10px; }
        .bet-buttons-container button { padding: 6px 12px; font-size: 0.8em; border-radius: 20px; }
        .info-box { font-size: 0.8em; padding: 6px 10px; margin: 3px; }
        .win-animation-content h2 { font-size: 1.8em; }
        .win-animation-content p { font-size: 1.5em; }
    }
  </style>
</head>
<body>
  
  <audio id="rollSound" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//mixkit-fast-sci-fi-sweep-1946.mp3"></audio>
  <audio id="winSmallSound" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//mixkit-money-bag-drop-1989.mp3"></audio>
  <audio id="winBigSound" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//mixkit-final-level-bonus-2061.mp3"></audio>
  <audio id="breakSound" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//mixkit-mechanical-crate-pick-up-3154%20(1).mp3"></audio>
  <div id="popup" class="popup"></div>
  <audio id="spinSound" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//mixkit-game-ball-tap-2073.mp3"></audio>
  <audio id="bgm" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//dj-background-music-background-music-free-music-music-free-for-use-221916%20(1).mp3" loop></audio>
  <audio id="freeSpinSound" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//mixkit-game-level-completed-2059.mp3"></audio>
  <audio id="freeSpinBGM" src="https://www.bensound.com/bensound-music/bensound-epic.mp3" loop></audio>
  
  <marquee>â€¢RASAKAN KEKUATAN ZEUS DENGAN KEMENANGAN TAK TERHINGGA!â€¢RAIH SCATTER DAN MASUKI GERBANG OLYMPUS UNTUK MAXWIN!â€¢</marquee>

  <h1>Gates of Olympus<hr></h1>
  <div class="slot-frame">
    <div class="slot-grid" id="grid"></div>
    <div class="multiplier" id="multiplierDisplay">x1</div>
  </div>

  <div class="controls-container">
    <div class="info-box balance-box" id="balanceDisplay">Saldo: Rp0</div>
    <div class="info-box bet-box" id="betDisplay">BET: 100</div>
    <div class="info-box freespin-box" id="freeSpinDisplay">Free Spins: 0</div>
  </div>

  <div class="bet-buttons-container">
    <button id="minBetBtn">MIN</button>
    <button id="betMinus">-</button>
    <button id="betPlus">+</button>
    <button id="maxBetBtn">MAX</button>
  </div>

  <button class="spin-button" id="spinButton">SPIN</button>

  <div id="freeSpinWinOverlay" class="win-animation-overlay">
    <div class="win-animation-content">
      <h2>FREE SPIN SELESAI!</h2>
      <p>TOTAL KEMENANGAN: <span id="freeSpinTotalWin">Rp0</span></p>
    </div>
  </div>

  <script>
        const grid = document.getElementById('grid');
    const spinButton = document.getElementById('spinButton');
    const balanceDisplay = document.getElementById('balanceDisplay');
    const betDisplay = document.getElementById('betDisplay');
    const multiplierDisplay = document.getElementById('multiplierDisplay');
    const rollSound = document.getElementById('rollSound');
    const winSmallSound = document.getElementById('winSmallSound');
    const winBigSound = document.getElementById('winBigSound');
    const breakSound = document.getElementById('breakSound');
    const betMinusBtn = document.getElementById('betMinus');
    const betPlusBtn = document = document.getElementById('betPlus');
    const minBetBtn = document.getElementById('minBetBtn');
    const maxBetBtn = document.getElementById('maxBetBtn');
    const freeSpinDisplay = document.getElementById('freeSpinDisplay');
    const freeSpinWinOverlay = document.getElementById('freeSpinWinOverlay');
    const freeSpinTotalWinDisplay = document.getElementById('freeSpinTotalWin');
    const bgm = document.getElementById('bgm');
    const freeSpinBGM = document.getElementById('freeSpinBGM');
    const freeSpinSound = document.getElementById('freeSpinSound');

    // Supabase Configuration - GANTI DENGAN KUNCI ANDA YANG SEBENARNYA!
    const SUPABASE_URL = 'https://vqmfachxnjyxwuavpgds.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZxbWZhY2h4bmp5eHd1YXZwZ2RzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg0MDYxNDAsImV4cCI6MjA2Mzk4MjE0MH0.Bzr8mUiEl8MzRWpVQ3_59eFxKk0EWZ3ca-4IEcpGLkk';
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Gates of Olympus grid size
    const width = 6;
    const height = 5;

    // Symbol data for Gates of Olympus
    const SYMBOLS_DATA = [
        { id: 'gem_blue', emoji: 'ðŸ”·', imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/simbolzeus//download%20(4).jpeg', payout: { '8': 0.25, '10': 0.5, '12': 0.75, '15': 1.25, '20': 2.5, '25': 5, '30': 8 } },
        { id: 'gem_green', emoji: 'ðŸ’š', imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/simbolzeus//BeautyPlus-image-extender.jpeg', payout: { '8': 0.4, '10': 0.8, '12': 1.2, '15': 2, '20': 4, '25': 7, '30': 10 } },
        { id: 'gem_yellow', emoji: 'ðŸ’›', imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/simbolzeus//download%20(2).jpeg', payout: { '8': 0.5, '10': 1, '12': 1.5, '15': 2.5, '20': 5, '25': 8, '30': 12 } },
        { id: 'gem_purple', emoji: 'ðŸ’œ', imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/simbolzeus//download.jpg', payout: { '8': 0.6, '10': 1.2, '12': 1.8, '15': 3, '20': 6, '25': 10, '30': 15 } },
        { id: 'gem_red', emoji: 'â¤ï¸', imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/simbolzeus//images%20(2)_11zon.jpg', payout: { '8': 0.75, '10': 1.5, '12': 2.25, '15': 4, '20': 8, '25': 12, '30': 20 } },
        { id: 'goblet', emoji: 'ðŸ†', imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/simbolzeus//images%20(3).jpeg', payout: { '8': 1, '10': 2, '12': 3, '15': 5, '20': 10, '25': 15, '30': 25 } },
        { id: 'ring', emoji: 'ðŸ’', imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/simbolzeus//images%20(6).jpeg', payout: { '8': 1.2, '10': 2.4, '12': 3.6, '15': 6, '20': 12, '25': 18, '30': 30 } },
        { id: 'hourglass', emoji: 'â³', imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/simbolzeus//images%20(7).jpeg', payout: { '8': 1.5, '10': 3, '12': 4.5, '15': 7.5, '20': 15, '25': 22.5, '30': 37.5 } },
    ];

    const ORB_BASE_ID = 'ORB_MULTIPLIER_SYMBOL';
    const ORBS_DATA = [
        { value: 2, imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/simbolzeus//BeautyPlus-image-extender%20(2).jpeg' },
        { value: 25, imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/zaus//25x.jpeg' },
        { value: 50, imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/zaus//50x.jpeg' },
        { value: 100, imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/simbolzeus//BeautyPlus-image-extender%20(1).jpeg' },
        { value: 500, imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/simbolzeus//download%20(6).jpeg' }
    ];

    const SCATTER_DATA = { id: 'SCATTER', emoji: 'ðŸ”±', imgUrl: 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/zaus//zeuz.jpeg', payout: { '4': 3, '5': 5, '6': 100 } };

    const ALL_SYMBOL_IDS = SYMBOLS_DATA.map(s => s.id).concat(ORB_BASE_ID, SCATTER_DATA.id);
    const REGULAR_SYMBOL_IDS = SYMBOLS_DATA.map(s => s.id);

    let currentSymbols = []; // Stores { id: 'symbol_id', value: <orb_value_if_orb>, imgUrl: <orb_specific_url_if_orb> }
    let balance = 0;
    const BET_LEVELS = [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000];
    let currentBetIndex = 0;
    let bet = BET_LEVELS[currentBetIndex];

    let currentGlobalMultiplier = 1;
    let freeSpinCount = 0;
    let totalFreeSpinWin = 0;
    let isInFreeSpinMode = false;
    let isSpinning = false;
    let globalUid = null;

    // --- Supabase Integration ---
    async function loadSaldo() {
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
            console.warn('Pengguna tidak login atau sesi berakhir. Mengalihkan ke halaman login...');
            window.location.href = "index.html";
            return;
        }

        globalUid = user.id;

        try {
            const { data: userData, error: fetchError } = await supabase
                .from('users_data')
                .select('saldo')
                .eq('user_id', globalUid)
                .single();

            if (fetchError && fetchError.code === 'PGRST116') {
                console.warn('Pengguna belum memiliki entri saldo. Membuat entri baru...');
                const initialBalance = 500000;

                const { data: newUserData, error: insertError } = await supabase
                    .from('users_data')
                    .insert([{ user_id: globalUid, saldo: initialBalance }])
                    .select('saldo')
                    .single();

                if (insertError) throw insertError;
                balance = newUserData.saldo;
                console.log('Saldo baru berhasil dibuat dan dimuat:', balance);
            } else if (fetchError) {
                throw fetchError;
            } else {
                balance = userData.saldo;
                console.log('Saldo berhasil dimuat:', balance);
            }
        } catch (error) {
            console.error('Error memuat saldo dari Supabase:', error.message);
            alert('Gagal memuat saldo. Silakan coba lagi.');
            balance = 0;
        } finally {
            updateBalance(0);
        }
    }

    async function saveBalanceToSupabase() {
        if (!globalUid) {
            console.warn('Tidak ada UID pengguna untuk menyimpan saldo.');
            return;
        }
        try {
            const { error } = await supabase
                .from('users_data')
                .update({ saldo: balance })
                .eq('user_id', globalUid);
            if (error) throw error;
            console.log('Saldo berhasil disimpan:', balance);
        } catch (error) {
            console.error('Error menyimpan saldo ke Supabase:', error.message);
        }
    }

    window.onload = () => {
        loadSaldo();
        init();
    };

    // --- Game Logic ---

    function getSymbolData(symbolObj) {
        if (!symbolObj || !symbolObj.id) return null;

        if (symbolObj.id === SCATTER_DATA.id) return SCATTER_DATA;
        if (symbolObj.id === ORB_BASE_ID) {
            return {
                id: ORB_BASE_ID,
                value: symbolObj.value,
                imgUrl: symbolObj.imgUrl
            };
        }
        return SYMBOLS_DATA.find(s => s.id === symbolObj.id);
    }

    function generateSingleRandomSymbol() {
        const rand = Math.random();
        const SCATTER_PROBABILITY = 1.01; // 1%
        const ORB_PROBABILITY = 0.015;    // 1.5%

        if (rand < SCATTER_PROBABILITY) {
            return { id: SCATTER_DATA.id };
        } else if (rand < SCATTER_PROBABILITY + ORB_PROBABILITY) {
            const randomOrb = ORBS_DATA[Math.floor(Math.random() * ORBS_DATA.length)];
            return {
                id: ORB_BASE_ID,
                value: randomOrb.value,
                imgUrl: randomOrb.imgUrl
            };
        } else {
            const regularId = REGULAR_SYMBOL_IDS[Math.floor(Math.random() * REGULAR_SYMBOL_IDS.length)];
            return { id: regularId };
        }
    }

    function renderGrid(symbolsArr) {
        grid.innerHTML = '';
        symbolsArr.forEach(symbolObj => {
            const div = document.createElement('div');
            div.className = 'tile';
            updateTileContent(div, symbolObj);
            grid.appendChild(div);
        });
    }

    function updateTileContent(tileElement, symbolObj) {
        tileElement.innerHTML = ''; // Clear existing content
        tileElement.classList.remove('special-symbol', 'scatter-symbol', 'break'); // Reset classes

        const baseSymbolData = getSymbolData(symbolObj);

        if (baseSymbolData && baseSymbolData.imgUrl) {
            const img = document.createElement('img');
            img.src = baseSymbolData.imgUrl;
            img.alt = baseSymbolData.id || 'symbol';
            tileElement.appendChild(img);
        } else if (baseSymbolData && baseSymbolData.emoji) {
            tileElement.textContent = baseSymbolData.emoji;
        } else {
            tileElement.textContent = '';
            console.warn("Could not render symbol, missing imgUrl or emoji:", symbolObj);
        }

        if (symbolObj && symbolObj.id === ORB_BASE_ID) {
            tileElement.classList.add('special-symbol');
        } else if (symbolObj && symbolObj.id === SCATTER_DATA.id) {
            tileElement.classList.add('scatter-symbol');
        }
    }

    async function animateTumbleDrop(symbolsBeforeTumble, symbolsAfterTumble, indicesToBreak) {
        const delay = ms => new Promise(res => setTimeout(res, ms));
        const cells = Array.from(grid.children);

        // Step 1: Animate breaking symbols
        if (indicesToBreak.length > 0) {
            animateWinningTiles(indicesToBreak);
            breakSound.currentTime = 0;
            breakSound.play().catch(e => console.log("Break sound play blocked:", e));
            await delay(500); // Wait for break animation
        }
        
        // Remove 'break' class and reset opacity for winning tiles (they will be replaced)
        // Dim non-winning tiles back to full opacity
        cells.forEach((tile, i) => {
            tile.classList.remove('break');
            if (!indicesToBreak.includes(i)) {
                tile.style.opacity = '1';
            }
        });

        // Step 2: Prepare for drop and new symbols
        const tilesToUpdate = []; // Stores { element, newSymbolObj, startYOffset }

        for (let col = 0; col < width; col++) {
            const emptyCellsInCol = []; // Store row indices of empty cells
            const symbolsToDropInCol = []; // Store { symbolObj, originalRow } for non-breaking symbols

            for (let row = height - 1; row >= 0; row--) { // From bottom to top
                const idx = row * width + col;
                if (indicesToBreak.includes(idx)) {
                    emptyCellsInCol.unshift(row); // Add to front so lowest empty row is at index 0
                } else {
                    symbolsToDropInCol.unshift({ symbolObj: symbolsBeforeTumble[idx], originalRow: row });
                }
            }
            
            // Now, symbolsToDropInCol has the symbols that will fall, ordered from top to bottom
            // emptyCellsInCol has the row indices that need to be filled, ordered from lowest to highest

            // Fill empty cells from the bottom up with existing symbols
            for (let i = 0; i < emptyCellsInCol.length; i++) {
                const targetRow = emptyCellsInCol[i];
                if (symbolsToDropInCol.length > 0) {
                    // An existing symbol will drop into this empty spot
                    const symbolToMove = symbolsToDropInCol.pop(); // Take from end (bottom-most falling symbol)
                    const originalIndex = symbolToMove.originalRow * width + col;
                    const targetIndex = targetRow * width + col;
                    
                    const tile = cells[originalIndex]; // Get the actual DOM element of the symbol that is falling

                    // Update the content of the target tile to the symbol that's falling
                    // This is important because the DOM element is moving from its original place to a new one
                    const targetTile = cells[targetIndex];
                    updateTileContent(targetTile, symbolToMove.symbolObj);
                    targetTile.style.transition = 'none'; // Disable transition for initial setup
                    
                    // Calculate drop distance in px
                    const dropDistance = (targetRow - symbolToMove.originalRow) * (targetTile.offsetHeight + 5); // 5px is tile gap
                    targetTile.style.transform = `translateY(${-dropDistance}px)`; // Initial position: "above" its target
                    targetTile.style.opacity = '0'; // Start invisible

                    tilesToUpdate.push({
                        element: targetTile,
                        newSymbolObj: symbolToMove.symbolObj,
                        targetIndex: targetIndex,
                        // For animation, we need to know its final destination and its starting point (relative to target)
                        startY: -dropDistance,
                        endY: 0
                    });

                } else {
                    // This empty spot needs a new symbol from the top
                    const targetIndex = targetRow * width + col;
                    const newSymbolObj = symbolsAfterTumble[targetIndex]; // Get new symbol from final grid state
                    const tile = cells[targetIndex]; // This tile was previously empty or winning, now filled by a new symbol

                    updateTileContent(tile, newSymbolObj); // Update content to new symbol
                    tile.style.transition = 'none';
                    tile.style.transform = 'translateY(-100vh)'; // Start far above
                    tile.style.opacity = '0'; // Start invisible

                    tilesToUpdate.push({
                        element: tile,
                        newSymbolObj: newSymbolObj,
                        targetIndex: targetIndex,
                        startY: '-100vh',
                        endY: 0
                    });
                }
            }
            // For symbols that didn't move but were previously dimmed, ensure they are full opacity again
            for (let row = 0; row < height; row++) {
                const idx = row * width + col;
                if (!indicesToBreak.includes(idx) && !emptyCellsInCol.includes(row)) {
                     // This symbol did not break and did not need to fall
                     cells[idx].style.opacity = '1';
                     cells[idx].style.transform = 'translateY(0)';
                     cells[idx].style.transition = 'none';
                }
            }
        }
        
        // This is crucial: Set currentSymbols to the post-tumble state BEFORE animating
        // So `getWinningTiles` on the next iteration gets the correct state.
        currentSymbols = symbolsAfterTumble;

        await delay(50); // Small delay to allow DOM to update initial positions

        // Step 3: Trigger the fall animation
        rollSound.currentTime = 0;
        rollSound.play().catch(e => console.log("Roll sound play blocked:", e));

        const animationPromises = [];
        tilesToUpdate.sort((a,b) => a.targetIndex - b.targetIndex); // Sort by target index for consistent staggering

        tilesToUpdate.forEach(animData => {
            const tile = animData.element;
            const rowIndex = Math.floor(animData.targetIndex / width);
            const fallDelay = rowIndex * 70; // Stagger by row for falling effect

            animationPromises.push(new Promise(resolve => {
                setTimeout(() => {
                    tile.style.transition = 'transform 0.5s cubic-bezier(0.2, 0.8, 0.4, 1.2), opacity 0.3s ease-out';
                    tile.style.transform = `translateY(${animData.endY}px)`;
                    tile.style.opacity = '1';

                    const onTransitionEnd = () => {
                        tile.removeEventListener('transitionend', onTransitionEnd);
                        // Ensure it resets to default
                        tile.style.transform = 'translateY(0)';
                        tile.style.opacity = '1';
                        tile.style.transition = 'transform 0.1s linear, box-shadow 0.3s ease';
                        resolve();
                    };
                    tile.addEventListener('transitionend', onTransitionEnd, { once: true });
                    // Fallback to ensure resolve in case transitionend doesn't fire
                    setTimeout(() => resolve(), 600);
                }, fallDelay);
            }));
        });

        await Promise.all(animationPromises);
        
        // Ensure all tiles are completely reset to default styles after all animations
        cells.forEach(tile => {
            tile.style.transform = 'translateY(0)';
            tile.style.opacity = '1';
            tile.classList.remove('break'); // Remove any lingering break classes
            tile.style.transition = 'transform 0.1s linear, box-shadow 0.3s ease'; // Reset to default transition
        });
    }

    // --- Gates of Olympus Specific Win Logic (Cluster Pays + Orbs) ---
    function getWinningTiles(symbolsArr) {
        const winningTiles = new Set(); // For regular cluster wins
        let scatterCount = 0;
        const scatterIndices = [];
        let currentTumbleOrbsMultiplier = 0;
        const orbIndices = new Set(); // Use Set to avoid duplicates if orbs are processed multiple times (unlikely here)
        let currentTumbleWinAmount = 0;

        for (let i = 0; i < symbolsArr.length; i++) {
            const symbolObj = symbolsArr[i];
            if (symbolObj && symbolObj.id === SCATTER_DATA.id) {
                scatterCount++;
                scatterIndices.push(i);
            } else if (symbolObj && symbolObj.id === ORB_BASE_ID) {
                currentTumbleOrbsMultiplier += symbolObj.value;
                orbIndices.add(i); // Add orb index to a set
            }
        }

        const uniqueSymbolIdsInGrid = new Set(symbolsArr.map(s => s ? s.id : null).filter(id => id !== null && id !== ORB_BASE_ID && id !== SCATTER_DATA.id));
        
        for (const symbolId of uniqueSymbolIdsInGrid) {
            let count = 0;
            const currentSymbolIndices = [];

            for (let i = 0; i < symbolsArr.length; i++) {
                if (symbolsArr[i] && symbolsArr[i].id === symbolId) {
                    count++;
                    currentSymbolIndices.push(i);
                }
            }

            if (count >= 8) {
                const symbolData = SYMBOLS_DATA.find(s => s.id === symbolId);
                const payoutKeys = Object.keys(symbolData.payout).map(Number).sort((a, b) => b - a);

                let payoutMultiplier = 0;
                for (const key of payoutKeys) {
                    if (count >= key) {
                        payoutMultiplier = symbolData.payout[key];
                        break;
                    }
                }
                
                if (payoutMultiplier > 0) {
                    currentTumbleWinAmount += bet * payoutMultiplier;
                    currentSymbolIndices.forEach(idx => winningTiles.add(idx)); // Add winning regular symbols
                } else {
                    console.warn(`Payout not defined for symbol ${symbolId} with count ${count}`);
                }
            }
        }
        
        // Orbs only break if there's a win from other symbols in the same tumble.
        // If there is a win, Orbs will also break and contribute their value.
        if (currentTumbleWinAmount > 0 && currentTumbleOrbsMultiplier > 0) {
            orbIndices.forEach(idx => winningTiles.add(idx)); // Add orb indices to winningTiles only if there was a win
        }

        // IMPORTANT: Scatters ONLY break if they trigger Free Spins.
        // They do NOT break just because there's a general win.
        let scattersToBreakIndices = [];
        if (scatterCount >= 4) { // Only mark scatters as breaking if Free Spins are triggered
            scattersToBreakIndices = scatterIndices;
        }


        return {
            winningTiles: Array.from(winningTiles), // Regular cluster wins + orbs (if associated with a win)
            scatterCount: scatterCount,
            scattersToBreakIndices: scattersToBreakIndices, // Only scatters that trigger free spins
            currentTumbleWinAmount: currentTumbleWinAmount,
            currentTumbleOrbsMultiplier: currentTumbleOrbsMultiplier
        };
    }


    function animateWinningTiles(indices) {
        document.querySelectorAll('.tile').forEach((tile, i) => {
            if (indices.includes(i)) {
                tile.classList.add('break'); // Apply break animation
            } else {
                // Dim non-winning symbols, but not scatters unless they also broke
                if (!tile.classList.contains('scatter-symbol')) {
                    tile.style.opacity = 0.5;
                }
            }
        });
    }

    // Function to calculate the next state of the grid after winning symbols break
    function calculateNextGridState(symbolsArr, indicesToBreak) {
        const nextSymbols = Array(width * height).fill(null);

        for (let col = 0; col < width; col++) {
            const columnSymbols = [];
            // Collect non-breaking symbols in this column, from bottom up
            for (let row = height - 1; row >= 0; row--) {
                const currentIdx = row * width + col;
                if (!indicesToBreak.includes(currentIdx)) {
                    columnSymbols.unshift(symbolsArr[currentIdx]); // Add to the front to maintain order from top to bottom
                }
            }

            // Determine how many new symbols are needed to fill the column
            const newSymbolsNeeded = height - columnSymbols.length;
            for (let i = 0; i < newSymbolsNeeded; i++) {
                columnSymbols.unshift(generateSingleRandomSymbol()); // Add new symbols to the top
            }

            // Place symbols back into the nextSymbols array for this column
            for (let row = 0; row < height; row++) {
                nextSymbols[row * width + col] = columnSymbols[row];
            }
        }
        return nextSymbols;
    }


    function updateBalance(amount) {
        balance += amount;
        balanceDisplay.textContent = `Saldo: Rp.${balance.toLocaleString('id-ID')}`;
    }

    function updateBetDisplay() {
        betDisplay.textContent = `BET: ${bet.toLocaleString('id-ID')}`;
    }

    function updateFreeSpinDisplay() {
        if (freeSpinCount > 0) {
            freeSpinDisplay.textContent = `Free Spins: ${freeSpinCount}`;
            freeSpinDisplay.style.display = 'block';
        } else {
            freeSpinDisplay.textContent = `Free Spins: 0`;
            freeSpinDisplay.style.display = 'none';
        }
    }

    function updateMultiplierDisplay(value) {
        multiplierDisplay.textContent = `x${value}`;
        multiplierDisplay.classList.add('zoom');
        setTimeout(() => multiplierDisplay.classList.remove('zoom'), 300);
    }

    function showPopup(message) {
        const popup = document.getElementById('popup');
        popup.textContent = message;
        popup.style.display = 'block';
        setTimeout(() => {
            popup.style.display = 'none';
        }, 1500);
    }

    async function showFreeSpinWinAnimation(totalWin) {
        freeSpinTotalWinDisplay.textContent = `Rp.${totalWin.toLocaleString('id-ID')}`;
        freeSpinWinOverlay.style.opacity = '1';
        freeSpinWinOverlay.style.visibility = 'visible';

        winBigSound.currentTime = 0;
        winBigSound.play().catch(e => console.log("Big win sound play blocked:", e));

        await new Promise(resolve => setTimeout(resolve, 5000));
        freeSpinWinOverlay.style.opacity = '0';
        freeSpinWinOverlay.style.visibility = 'hidden';
    }

    async function spin() {
        if (isSpinning) return;
        if (!isInFreeSpinMode && balance < bet) {
            showPopup('Saldo tidak cukup!');
            return;
        }

        isSpinning = true;
        spinButton.disabled = true;
        betMinusBtn.disabled = true;
        betPlusBtn.disabled = true;
        minBetBtn.disabled = true;
        maxBetBtn.disabled = true;

        if (!isInFreeSpinMode) {
            updateBalance(-bet);
            currentGlobalMultiplier = 1; // Reset multiplier in base game spin
            updateMultiplierDisplay(currentGlobalMultiplier);
        } else {
            freeSpinCount--;
            updateFreeSpinDisplay();
        }
        
        // Reset tile appearance for a new spin - only remove 'break' and reset opacity
        document.querySelectorAll('.tile').forEach(tile => {
            tile.style.opacity = 1;
            tile.classList.remove('break');
        });

        // Initial spin symbols
        if (!isInFreeSpinMode || freeSpinCount === 15) { // Only generate entirely new grid on first free spin or base game
             currentSymbols = [];
             for (let i = 0; i < width * height; i++) {
                 currentSymbols.push(generateSingleRandomSymbol());
             }
             renderGrid(currentSymbols); // Initial render with newly generated symbols
        }
        // If it's a subsequent free spin, currentSymbols already holds the previous state after tumble
        // and renderGrid is called inside animateTumbleDrop with the new state.

        let currentSpinTotalWin = 0;
        let chainReactionOccurredInSpin = false;
        let orbMultiplierAccumulatedThisSpin = 0; // Accumulate orbs for the entire chain reaction
        let freeSpinTriggeredThisSpin = false; // Flag to prevent multiple free spin triggers per spin

        // Loop for tumbles
        while (true) {
            const { winningTiles, scatterCount, scattersToBreakIndices, currentTumbleWinAmount, currentTumbleOrbsMultiplier } = getWinningTiles(currentSymbols);

            let tumbleHadWin = false;
            
            if (currentTumbleOrbsMultiplier > 0) {
                orbMultiplierAccumulatedThisSpin += currentTumbleOrbsMultiplier;
                updateMultiplierDisplay(orbMultiplierAccumulatedThisSpin);
            }

            let finalTumbleWin = currentTumbleWinAmount;
            if (currentTumbleWinAmount > 0 && orbMultiplierAccumulatedThisSpin > 0) {
                 finalTumbleWin = currentTumbleWinAmount * orbMultiplierAccumulatedThisSpin;
            }

            let allIndicesToBreak = new Set(winningTiles); // Start with regular wins + orbs
            
            // Add scatters to break ONLY if they trigger free spins
            if (scattersToBreakIndices.length > 0) {
                scattersToBreakIndices.forEach(idx => allIndicesToBreak.add(idx));
            }

            if (allIndicesToBreak.size > 0) {
                tumbleHadWin = true;
                chainReactionOccurredInSpin = true;
                currentSpinTotalWin += finalTumbleWin;

                // Calculate the next grid state before animating
                const nextGridSymbols = calculateNextGridState(currentSymbols, Array.from(allIndicesToBreak));
                await animateTumbleDrop(currentSymbols, nextGridSymbols, Array.from(allIndicesToBreak));
                // currentSymbols is updated inside animateTumbleDrop now
                await new Promise(res => setTimeout(res, 600)); // Short pause before next win check
            } else {
                break; // No more wins, stop tumbling
            }

            // Check for Free Spin trigger (only trigger once per main spin)
            // This logic must be outside the `tumbleHadWin` block IF free spins can be triggered without a win.
            // In Gates of Olympus, 4 scatters always trigger, regardless of other wins.
            if (!isInFreeSpinMode && scatterCount >= 4 && !freeSpinTriggeredThisSpin) {
                let newFreeSpins = 0;
                if (scatterCount >= 4) newFreeSpins = 15; // 4+ scatters give 15 free spins
                // else if (scatterCount >= 5) newFreeSpins = ... // Gates of Olympus typically 15 FS for 4+, +5 for retrigger by 3+ during FS
                
                freeSpinCount += newFreeSpins;
                showPopup(`Anda mendapatkan ${newFreeSpins} Free Spins!`);
                updateFreeSpinDisplay();
                freeSpinSound.currentTime = 0;
                freeSpinSound.play().catch(e => console.log("Free spin sound play blocked:", e));
                bgm.pause();
                bgm.currentTime = 0;
                freeSpinBGM.volume = 0.3;
                freeSpinBGM.play().catch(e => console.log("Free spin BGM play blocked:", e));
                isInFreeSpinMode = true;
                totalFreeSpinWin = 0; // Reset total free spin win for the new free spin round
                orbMultiplierAccumulatedThisSpin = 0; // Reset orb multiplier for free spins
                updateMultiplierDisplay(orbMultiplierAccumulatedThisSpin);
                freeSpinTriggeredThisSpin = true; // Mark as triggered
                break; // Exit tumble loop to start free spin mode
            } else if (isInFreeSpinMode && scatterCount >= 3) { // Retrigger in Free Spin
                 let retriggerSpins = 5; // 3+ scatters retrigger 5 spins
                 freeSpinCount += retriggerSpins;
                 showPopup(`+${retriggerSpins} Free Spins!`);
                 updateFreeSpinDisplay();
                 // No break here, allow more tumbles if they happen
            }
        }

        // After all tumbles are done for the current spin
        if (isInFreeSpinMode) {
            totalFreeSpinWin += currentSpinTotalWin;
        } else {
            updateBalance(currentSpinTotalWin); // Add win to balance in base game
        }
        
        if (currentSpinTotalWin > 0) {
            if (currentSpinTotalWin >= bet * 10) { // Big Win threshold
                winBigSound.currentTime = 0;
                winBigSound.play().catch(e => console.log("Big win sound play blocked:", e));
            } else {
                winSmallSound.currentTime = 0;
                winSmallSound.play().catch(e => console.log("Small win sound play blocked:", e));
            }
            showPopup(`MENANG: Rp.${currentSpinTotalWin.toLocaleString('id-ID')}!`);
        } else if (!isInFreeSpinMode && !chainReactionOccurredInSpin && !freeSpinTriggeredThisSpin) {
             showPopup('Coba lagi!');
        }

        // Handle continuation or end of Free Spins
        if (freeSpinCount > 0 && isInFreeSpinMode) {
            await new Promise(res => setTimeout(res, 1500)); // Pause before next FS spin
            spin(); // Continue Free Spin
        } else {
            if (isInFreeSpinMode) { // Just finished Free Spins
                freeSpinBGM.pause();
                freeSpinBGM.currentTime = 0;
                bgm.play().catch(e => console.log("BGM play blocked:", e));
                isInFreeSpinMode = false;
                await showFreeSpinWinAnimation(totalFreeSpinWin);
                updateBalance(totalFreeSpinWin); // Add total free spin win to balance
                totalFreeSpinWin = 0; // Reset total free spin win
            }

            // Ensure all tiles are back to full opacity and without break class
            document.querySelectorAll('.tile').forEach(tile => {
                tile.style.opacity = 1;
                tile.classList.remove('break');
            });

            spinButton.disabled = false;
            betMinusBtn.disabled = false;
            betPlusBtn.disabled = false;
            minBetBtn.disabled = false;
            maxBetBtn.disabled = false;
            updateFreeSpinDisplay();
            currentGlobalMultiplier = 1; // Ensure multiplier resets after normal spin
            updateMultiplierDisplay(currentGlobalMultiplier);
        }

        await saveBalanceToSupabase();
        isSpinning = false;
    }

    // Bet adjustment functions
    betMinusBtn.onclick = () => {
        if (isSpinning) return;
        currentBetIndex = Math.max(0, currentBetIndex - 1);
        bet = BET_LEVELS[currentBetIndex];
        updateBetDisplay();
    };
    betPlusBtn.onclick = () => {
        if (isSpinning) return;
        currentBetIndex = Math.min(BET_LEVELS.length - 1, currentBetIndex + 1);
        bet = BET_LEVELS[currentBetIndex];
        updateBetDisplay();
    };
    minBetBtn.onclick = () => {
        if (isSpinning) return;
        currentBetIndex = 0;
        bet = BET_LEVELS[currentBetIndex];
        updateBetDisplay();
    };
    maxBetBtn.onclick = () => {
        if (isSpinning) return;
        currentBetIndex = BET_LEVELS.length - 1;
        bet = BET_LEVELS[currentBetIndex];
        updateBetDisplay();
    };
    spinButton.onclick = spin;

    // Initialize audio volumes
    bgm.volume = 0.3;
    freeSpinBGM.volume = 0.3;
    rollSound.volume = 0.3;
    winSmallSound.volume = 0.5;
    winBigSound.volume = 0.8;
    breakSound.volume = 0.7;
    document.getElementById('spinSound').volume = 0.5;
    document.getElementById('freeSpinSound').volume = 0.6;

    function init() {
      currentSymbols = []; // Start with an empty grid, then fill with initial symbols
      for (let i = 0; i < width * height; i++) {
          currentSymbols.push(generateSingleRandomSymbol());
      }
      renderGrid(currentSymbols); // Initial render
      updateBalance(0);
      updateBetDisplay();
      updateFreeSpinDisplay();
      updateMultiplierDisplay(currentGlobalMultiplier);

      bgm.play().catch(() => {
        document.body.addEventListener('click', () => {
          bgm.play();
        }, { once: true });
      });
    }

    document.addEventListener('DOMContentLoaded', init);

  </script>
</body>
</html>