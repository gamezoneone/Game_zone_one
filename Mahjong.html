<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mahjong Ways - Slot Buah (Prototype)</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            font-family: 'Segoe UI Emoji', 'Apple Color Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
            overflow: hidden; /* Penting untuk animasi gulir */
        }
        .game-container {
            border: 4px solid #4CAF50; /* Hijau seperti Mahjong Ways */
            padding: 25px;
            border-radius: 15px;
            background-color: #fff;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            position: relative;
            max-width: 700px; /* Lebar disesuaikan untuk 5 reel */
            width: 95%;
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        .info-bar {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            font-size: 1.3em;
            font-weight: bold;
            color: #555;
        }
        .reels-container {
            display: flex;
            justify-content: center;
            gap: 5px; /* Jarak antar reel lebih kecil */
            margin-bottom: 30px;
            height: 480px; /* Tinggi disesuaikan untuk 4 baris simbol (4 * 120px) */
            border: 2px solid #ccc;
            border-radius: 8px;
            background-color: #e0e0e0;
            overflow: hidden;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
            position: relative; /* Untuk posisi absolut simbol */
        }
        .reel {
            width: 130px; /* Lebar setiap gulungan */
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            border-right: 1px dashed #ddd; /* Pemisah visual antar gulungan */
            box-sizing: border-box;
            position: relative;
            overflow: hidden; /* Reel sendiri harus menyembunyikan simbol yang keluar */
        }
        .reel:last-child {
            border-right: none;
        }
        .symbol {
            font-size: 3.5em; /* Ukuran emoji */
            width: 100%;
            height: 120px; /* Tinggi setiap simbol */
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            flex-shrink: 0;
            transition: transform 0.5s ease-out; /* Untuk animasi jatuh */
            background-color: #f8f8f8;
            border-bottom: 1px solid #eee;
            box-sizing: border-box;
        }
        /* Tambahkan efek untuk simbol WILD dan SCATTER */
        .symbol.wild {
            background-color: #e6ffe6; /* Light green */
            border: 2px solid #00aa00;
            box-shadow: 0 0 10px rgba(0,255,0,0.5);
        }
        .symbol.scatter {
            background-color: #fff0e6; /* Light orange */
            border: 2px solid #ff9900;
            box-shadow: 0 0 10px rgba(255,165,0,0.5);
        }
        /* Animasi simbol pecah */
        .symbol.winning {
            animation: winning-explode 0.5s forwards;
        }
        @keyframes winning-explode {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
        }
        button {
            padding: 12px 25px;
            font-size: 1.3em;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        #bet-minus, #bet-plus {
            background-color: #FFC107;
            color: #333;
        }
        #bet-minus:active, #bet-plus:active {
            transform: translateY(2px);
        }
        #spin-button {
            background-color: #007BFF;
            color: white;
            padding: 15px 35px;
            font-size: 1.6em;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        #spin-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #spin-button:active {
            transform: translateY(3px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        #loading-message {
            font-size: 1.5em;
            color: #555;
            margin-top: 20px;
        }
        #free-spin-info {
            font-size: 1.2em;
            color: #d9534f;
            font-weight: bold;
            margin-top: 10px;
            display: none; /* Akan ditampilkan saat free spin aktif */
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Mahjong buah</h1>
        <div class="info-bar">
            <div>Saldo: <span id="current-balance">Memuat...</span></div>
            <div>Bet: <span id="current-bet">200</span></div>
            <div>Multiplier: <span id="current-multiplier">1x</span></div>
        </div>

        <div class="reels-container" id="reels-container">
            </div>

        <div class="controls">
            <button id="bet-minus">- Bet</button>
            <button id="spin-button" disabled>SPIN</button>
            <button id="bet-plus">+ Bet</button>
        </div>
        <div id="loading-message">Mengambil data saldo...</div>
        <div id="free-spin-info">FREE SPINS: <span id="free-spin-count">0</span></div>
    </div>

    <script>const supabase = window.supabase.createClient(
        'https://vqmfachxnjyxwuavpgds.supabase.co',
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZxbWZhY2h4bmp5eHd1YXZwZ2RzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg0MDYxNDAsImV4cCI6MjA2Mzk4MjE0MH0.Bzr8mUiEl8MzRWpVQ3_59eFxKk0EWZ3ca-4IEcpGLkk'
    );


        const supabase = Supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      
        const balanceDisplay = document.getElementById('current-balance');
        const betDisplay = document.getElementById('current-bet');
        const multiplierDisplay = document.getElementById('current-multiplier');
        const spinButton = document.getElementById('spin-button');
        const betMinusButton = document.getElementById('bet-minus');
        const betPlusButton = document.getElementById('bet-plus');
        const reelsContainer = document.getElementById('reels-container');
        const loadingMessage = document.getElementById('loading-message');
        const freeSpinInfo = document.getElementById('free-spin-info');
        const freeSpinCountDisplay = document.getElementById('free-spin-count');

        let userId = 1; // Untuk demo, ID pengguna tetap. Sesungguhnya dari sesi login.
        let balance = 0;
        let currentBet = 200;
        let currentMultiplier = 1;
        let freeSpins = 0; // Jumlah free spin
        const minBet = 200;
        const betIncrement = 100;
        const maxBet = 1000;

        const SYMBOL_HEIGHT = 120; // Tinggi satu simbol dalam piksel
        const NUM_ROWS = 4; // 4 baris simbol per reel
        const NUM_REELS = 5; // 5 reel
        const VISIBLE_SYMBOLS = NUM_ROWS; // Jumlah simbol yang terlihat di setiap reel

        // Definisi Simbol: Menambahkan Wild dan Scatter
        const symbols = ['ðŸ’', 'ðŸ‡', 'ðŸ‰', 'ðŸ‹', 'ðŸŠ', 'ðŸ“', 'ðŸŒ', 'ðŸ'];
        const WILD_SYMBOL = 'â­'; // Simbol Wild
        const SCATTER_SYMBOL = 'ðŸ’°'; // Simbol Scatter (koin atau sejenisnya)

        // Simbol lengkap yang mungkin muncul di reel
        const allPossibleSymbols = [...symbols, WILD_SYMBOL, SCATTER_SYMBOL];

        // Aturan pembayaran (contoh sederhana)
        // Di game sungguhan, ada banyak payline dan kombinasi
        const payoutRates = {
            'ðŸ’ðŸ’ðŸ’': 5, 'ðŸ’ðŸ’ðŸ’ðŸ’': 10, 'ðŸ’ðŸ’ðŸ’ðŸ’ðŸ’': 20,
            'ðŸ‡ðŸ‡ðŸ‡': 7, 'ðŸ‡ðŸ‡ðŸ‡ðŸ‡': 15, 'ðŸ‡ðŸ‡ðŸ‡ðŸ‡ðŸ‡': 25,
            'ðŸ‰ðŸ‰ðŸ‰': 10, 'ðŸ‰ðŸ‰ðŸ‰ðŸ‰': 20, 'ðŸ‰ðŸ‰ðŸ‰ðŸ‰ðŸ‰': 30,
            'ðŸ‹ðŸ‹ðŸ‹': 15, 'ðŸ‹ðŸ‹ðŸ‹ðŸ‹': 25, 'ðŸ‹ðŸ‹ðŸ‹ðŸ‹ðŸ‹': 40,
            'ðŸŠðŸŠðŸŠ': 20, 'ðŸŠðŸŠðŸŠðŸŠ': 30, 'ðŸŠðŸŠðŸŠðŸŠðŸŠ': 50,
            // Perlu ditambahkan payout untuk 3, 4, 5 simbol Wild, dll.
            // Atau untuk kombinasi dengan Wild
        };

        // Current game grid (2D array: reels[reelIndex][rowIndex])
        let currentReelGrid = Array(NUM_REELS).fill(null).map(() => Array(NUM_ROWS).fill(null));

        // --- SUPABASE FUNCTIONS ---
        async function fetchBalanceFromSupabase(id) {
            try {
                loadingMessage.textContent = "Mengambil data saldo...";
                const { data, error } = await supabase
                    .from('users_data')
                    .select('saldo')
                    .eq('id', id)
                    .single();

                if (error) {
                    console.error('Error fetching balance:', error.message);
                    loadingMessage.textContent = `Error: ${error.message}. Saldo tidak bisa diambil.`;
                    spinButton.disabled = true;
                    return;
                }

                if (data && data.saldo !== undefined) {
                    balance = data.saldo;
                    updateDisplay();
                    loadingMessage.textContent = "Saldo berhasil dimuat!";
                    spinButton.disabled = false;
                } else {
                    console.warn(`No saldo found for user ID: ${id}. Initializing with default balance.`);
                    balance = 10000;
                    // Coba masukkan pengguna baru jika ID tidak ditemukan
                    const { data: insertData, error: insertError } = await supabase
                        .from('users_data')
                        .insert([{ id: id, username: `user${id}`, saldo: balance }]);
                    if (insertError) {
                        console.error('Error inserting new user:', insertError.message);
                        loadingMessage.textContent = `Gagal membuat user baru: ${insertError.message}.`;
                        spinButton.disabled = true;
                        return;
                    }
                    console.log('New user created:', insertData);
                    updateDisplay();
                    loadingMessage.textContent = "User tidak ditemukan, user baru dibuat dengan saldo default.";
                    spinButton.disabled = false;
                }
            } catch (err) {
                console.error('Unexpected error fetching balance:', err);
                loadingMessage.textContent = `Terjadi kesalahan tak terduga: ${err.message}.`;
                spinButton.disabled = true;
            }
        }
        async function updateBalanceInSupabase(id, newBalance) {
            try {
                const { data, error } = await supabase
                    .from('users_data')
                    .update({ saldo: newBalance })
                    .eq('id', id);

                if (error) {
                    console.error('Error updating balance:', error.message);
                    alert(`Gagal menyimpan saldo ke database: ${error.message}`);
                    return false;
                }
                console.log('Balance updated successfully:', data);
                return true;
            } catch (err) {
                console.error('Unexpected error updating balance:', err);
                alert(`Terjadi kesalahan tak terduga saat memperbarui saldo: ${err.message}`);
                return false;
            }
        }

        // --- GAME LOGIC FUNCTIONS ---

        function updateDisplay() {
            balanceDisplay.textContent = balance.toFixed(0);
            betDisplay.textContent = currentBet;
            multiplierDisplay.textContent = `${currentMultiplier}x`;
            freeSpinCountDisplay.textContent = freeSpins;
            freeSpinInfo.style.display = freeSpins > 0 ? 'block' : 'none';
        }

        /**
         * Mengisi satu reel dengan simbol acak untuk efek putaran.
         * @param {HTMLElement} reelElement Elemen div reel.
         * @returns {Array<string>} Array simbol yang dihasilkan untuk reel ini (sebelum di-render).
         */
        function getRandomReelSymbols(num) {
            const tempSymbols = [];
            for (let i = 0; i < num; i++) {
                // Probabilitas Wild/Scatter lebih rendah
                let symbol;
                const rand = Math.random();
                if (rand < 0.05) { // 5% chance for Wild
                    symbol = WILD_SYMBOL;
                } else if (rand < 0.10) { // 5% chance for Scatter (total 10%)
                    symbol = SCATTER_SYMBOL;
                } else {
                    symbol = symbols[Math.floor(Math.random() * symbols.length)];
                }
                tempSymbols.push(symbol);
            }
            return tempSymbols;
        }

        /**
         * Merender simbol ke dalam elemen reel.
         * @param {HTMLElement} reelElement Elemen div reel.
         * @param {Array<string>} symbolsToRender Array simbol yang akan dirender.
         */
        function renderReelSymbols(reelElement, symbolsToRender) {
            reelElement.innerHTML = '';
            symbolsToRender.forEach(symbol => {
                const symbolDiv = document.createElement('div');
                symbolDiv.classList.add('symbol');
                symbolDiv.textContent = symbol;
                if (symbol === WILD_SYMBOL) symbolDiv.classList.add('wild');
                if (symbol === SCATTER_SYMBOL) symbolDiv.classList.add('scatter');
                reelElement.appendChild(symbolDiv);
            });
        }

        /**
         * Menginisialisasi grid reel dengan simbol awal.
         */
        function initializeReels() {
            reelsContainer.innerHTML = ''; // Clear existing reels
            for (let i = 0; i < NUM_REELS; i++) {
                const reelElement = document.createElement('div');
                reelElement.classList.add('reel');
                reelElement.id = `reel${i}`;
                reelsContainer.appendChild(reelElement);

                currentReelGrid[i] = getRandomReelSymbols(NUM_ROWS); // Generate 4 symbols
                renderReelSymbols(reelElement, currentReelGrid[i]);
            }
        }

        /**
         * Fungsi utama untuk memutar reel.
         */
        async function spinReels() {
            if (freeSpins === 0 && balance < currentBet) {
                alert("Saldo tidak cukup! Silakan tambahkan saldo atau kurangi Bet.");
                return;
            }

            if (freeSpins === 0) { // Hanya kurangi bet jika bukan free spin
                balance -= currentBet;
            } else {
                freeSpins--; // Kurangi free spin count
            }
            currentMultiplier = 1; // Reset multiplier setiap putaran baru (sebelum cascading)

            updateDisplay();
            spinButton.disabled = true;
            betMinusButton.disabled = true;
            betPlusButton.disabled = true;

            const tempReelResults = []; // Untuk menyimpan hasil spin awal

            for (let i = 0; i < NUM_REELS; i++) {
                const reelElement = document.getElementById(`reel${i}`);
                const spinningSymbols = getRandomReelSymbols(NUM_ROWS * 5); // Lebih banyak simbol untuk efek gulir
                renderReelSymbols(reelElement, spinningSymbols); // Render symbols for spinning

                // Animasi gulir
                reelElement.style.transition = `transform ${2 + (i * 0.3)}s cubic-bezier(0.25, 0.1, 0.25, 1)`; // Ease-out lebih mulus
                reelElement.style.transform = `translateY(-${(spinningSymbols.length - NUM_ROWS) * SYMBOL_HEIGHT}px)`; // Gulir ke akhir

                await new Promise(resolve => setTimeout(resolve, (2000 + (i * 300))));

                // Set posisi akhir dan simbol nyata
                reelElement.style.transition = 'none';
                reelElement.style.transform = 'translateY(0)'; // Reset posisi

                // Tentukan simbol akhir untuk reel ini dan simpan
                const finalReelSymbols = getRandomReelSymbols(NUM_ROWS);
                tempReelResults.push(finalReelSymbols);
                renderReelSymbols(reelElement, finalReelSymbols); // Render final symbols
            }

            currentReelGrid = tempReelResults; // Update grid global

            // Cascading Wins Loop
            let hasWonThisCascade = true;
            let totalSpinWin = 0;

            while(hasWonThisCascade) {
                await new Promise(resolve => setTimeout(resolve, 500)); // Jeda sebentar sebelum cek cascade

                const { winAmount, winningCombinations } = checkWin(currentReelGrid);
                totalSpinWin += winAmount;

                if (winAmount > 0) {
                    balance += winAmount;
                    currentMultiplier = Math.min(currentMultiplier * 2, 5); // Multiplier: 1x, 2x, 3x, 4x, 5x
                    updateDisplay();
                    alert(`ðŸŽ‰ Menang: ${winAmount.toFixed(0)}! Multiplier: ${currentMultiplier}x ðŸŽ‰`);

                    // Animate winning symbols and remove them
                    await animateWinningSymbols(winningCombinations);
                    await dropAndFillReels(winningCombinations);

                    hasWonThisCascade = true; // Lanjutkan cascade jika ada kemenangan
                } else {
                    hasWonThisCascade = false; // Hentikan cascade jika tidak ada kemenangan
                }
            }

            // Setelah semua cascade selesai, cek Scatter dan aktifkan tombol
            await checkScatterAndFreeSpins();

            await updateBalanceInSupabase(userId, balance); // Simpan saldo final ke Supabase
            spinButton.disabled = false;
            betMinusButton.disabled = false;
            betPlusButton.disabled = false;
        }

        /**
         * Menganimasikan simbol yang menang dan menghapusnya dari DOM.
         * @param {Array<Object>} winningCombinations Daftar kombinasi yang menang.
         */
        async function animateWinningSymbols(winningCombinations) {
            const symbolsToRemove = new Set();
            winningCombinations.forEach(combo => {
                combo.positions.forEach(pos => {
                    // pos = {reel: i, row: j}
                    const reelElement = document.getElementById(`reel${pos.reel}`);
                    const symbolElement = reelElement.children[pos.row];
                    if (symbolElement) {
                        symbolElement.classList.add('winning');
                        symbolsToRemove.add(symbolElement);
                    }
                });
            });

            await new Promise(resolve => setTimeout(resolve, 500)); // Tunggu animasi selesai

            // Hapus elemen yang menang (setelah animasi pecah)
            symbolsToRemove.forEach(symbolElement => symbolElement.remove());
        }

        /**
         * Menjatuhkan simbol yang tersisa dan mengisi dengan simbol baru.
         * @param {Array<Object>} winningCombinations Daftar kombinasi yang menang.
         */
        async function dropAndFillReels(winningCombinations) {
            const symbolsToRemoveMap = new Map(); // Map: reelIndex -> Set of rowIndices to remove
            winningCombinations.forEach(combo => {
                combo.positions.forEach(pos => {
                    if (!symbolsToRemoveMap.has(pos.reel)) {
                        symbolsToRemoveMap.set(pos.reel, new Set());
                    }
                    symbolsToRemoveMap.get(pos.reel).add(pos.row);
                });
            });

            for (let i = 0; i < NUM_REELS; i++) {
                const reelElement = document.getElementById(`reel${i}`);
                const rowsToRemove = symbolsToRemoveMap.get(i) || new Set();
                let newReelContent = [];

                // Jatuhkan simbol yang tersisa
                for (let j = 0; j < NUM_ROWS; j++) {
                    if (!rowsToRemove.has(j)) {
                        newReelContent.push(currentReelGrid[i][j]);
                    }
                }

                // Tambahkan simbol baru di bagian atas
                const numNewSymbols = NUM_ROWS - newReelContent.length;
                for (let k = 0; k < numNewSymbols; k++) {
                    newReelContent.unshift(getRandomReelSymbols(1)[0]); // Tambahkan di depan array (jatuh dari atas)
                }
                currentReelGrid[i] = newReelContent; // Update grid global

                // Render ulang reel dengan animasi jatuh
                reelElement.innerHTML = '';
                newReelContent.forEach((symbol, index) => {
                    const symbolDiv = document.createElement('div');
                    symbolDiv.classList.add('symbol');
                    symbolDiv.textContent = symbol;
                    if (symbol === WILD_SYMBOL) symbolDiv.classList.add('wild');
                    if (symbol === SCATTER_SYMBOL) symbolDiv.classList.add('scatter');
                    // Tambahkan transisi untuk animasi jatuh
                    symbolDiv.style.transform = `translateY(-${numNewSymbols * SYMBOL_HEIGHT}px)`;
                    reelElement.appendChild(symbolDiv);

                    // Memicu animasi setelah dirender
                    requestAnimationFrame(() => {
                        symbolDiv.style.transition = 'transform 0.3s ease-out';
                        symbolDiv.style.transform = 'translateY(0)';
                    });
                });
            }
            await new Promise(resolve => setTimeout(resolve, 500)); // Beri waktu animasi jatuh
        }


        /**
         * Mengecek kemenangan pada grid saat ini.
         * @param {Array<Array<string>>} grid Current reel grid state.
         * @returns {Object} { winAmount: number, winningCombinations: Array<Object> }
         */
        function checkWin(grid) {
            let winAmount = 0;
            const winningCombinations = []; // Untuk menyimpan posisi simbol yang menang

            // Untuk Mahjong Ways, ini adalah 243 Ways (atau lebih).
            // Ini akan sangat kompleks dan memerlukan algoritma khusus.
            // Untuk demo ini, kita akan lakukan pengecekan sederhana untuk 3+ simbol yang cocok dari kiri ke kanan.
            // Dan pertimbangkan WILD_SYMBOL sebagai pengganti.

            // Contoh pengecekan untuk setiap baris (horizontal)
            for (let row = 0; row < NUM_ROWS; row++) {
                let currentCombo = [];
                let currentSymbol = '';
                let comboCount = 0;
                let comboPositions = [];

                for (let reel = 0; reel < NUM_REELS; reel++) {
                    const symbolInPosition = grid[reel][row];

                    // Abaikan SCATTER untuk kemenangan payline biasa
                    if (symbolInPosition === SCATTER_SYMBOL) {
                        currentCombo = [];
                        currentSymbol = '';
                        comboCount = 0;
                        comboPositions = [];
                        continue;
                    }

                    if (comboCount === 0 || (symbolInPosition === currentSymbol || symbolInPosition === WILD_SYMBOL)) {
                        if (comboCount === 0 && symbolInPosition !== WILD_SYMBOL) {
                            currentSymbol = symbolInPosition;
                        }
                        comboCount++;
                        comboPositions.push({ reel: reel, row: row });
                    } else if (symbolInPosition !== WILD_SYMBOL && symbolInPosition !== currentSymbol) {
                        // Jika simbol berbeda (dan bukan wild), reset combo
                        if (currentSymbol !== WILD_SYMBOL && payoutRates[currentSymbol.repeat(comboCount)]) {
                            // Cek apakah combo sebelumnya menang
                            if (comboCount >= 3) {
                                winAmount += currentBet * payoutRates[currentSymbol.repeat(comboCount)];
                                winningCombinations.push({ symbol: currentSymbol, count: comboCount, positions: [...comboPositions] });
                            }
                        }
                        currentSymbol = symbolInPosition;
                        comboCount = 1;
                        comboPositions = [{ reel: reel, row: row }];
                    }
                }
                // Cek combo terakhir setelah loop reel selesai
                if (currentSymbol !== WILD_SYMBOL && payoutRates[currentSymbol.repeat(comboCount)]) {
                    if (comboCount >= 3) {
                        winAmount += currentBet * payoutRates[currentSymbol.repeat(comboCount)];
                        winningCombinations.push({ symbol: currentSymbol, count: comboCount, positions: [...comboPositions] });
                    }
                }
            }

            // Implementasi lebih lanjut untuk 243 Ways akan jauh lebih rumit,
            // melibatkan pengecekan pola di seluruh grid, bukan hanya baris.

            return { winAmount, winningCombinations };
        }


        /**
         * Mengecek simbol Scatter dan memicu Free Spins.
         */
        async function checkScatterAndFreeSpins() {
            let scatterCount = 0;
            const scatterPositions = [];
            for (let i = 0; i < NUM_REELS; i++) {
                for (let j = 0; j < NUM_ROWS; j++) {
                    if (currentReelGrid[i][j] === SCATTER_SYMBOL) {
                        scatterCount++;
                        scatterPositions.push({ reel: i, row: j });
                    }
                }
            }
            if (scatterCount >= 3) {
                const bonusSpins = 10; // Contoh: 10 free spins untuk 3 scatter
                freeSpins += bonusSpins;
                updateDisplay();
                alert(`âœ¨ Selamat! Anda mendapatkan ${bonusSpins} FREE SPINS! âœ¨`);
                // Animasi scatter bisa ditambahkan di sini
            }
        }


        // --- EVENT LISTENERS ---

        betPlusButton.addEventListener('click', () => {
            if (currentBet < maxBet) {
                currentBet += betIncrement;
                updateDisplay();
            }
        });

        betMinusButton.addEventListener('click', () => {
            if (currentBet > minBet) {
                currentBet -= betIncrement;
                updateDisplay();
            }
        });

        spinButton.addEventListener('click', () => {
            if (freeSpins > 0) {
                spinReels(); // Langsung spin jika ada free spin
            } else if (balance >= currentBet) {
                spinReels(); // Spin normal jika saldo cukup
            } else {
                alert("Saldo tidak cukup!");
            }
        });


        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', async () => {
            await fetchBalanceFromSupabase(userId);
            initializeReels(); // Render reel awal
        });
    </script>
</body>
</html>