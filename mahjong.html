<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mahjong Slot</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
   const supabase = window.supabase.createClient(
      'https://vqmfachxnjyxwuavpgds.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZxbWZhY2h4njl5eHd1YXZwZ2RzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg0MDYxNDAsImV4cCI6MjA2Mzk4MjE0MH0.Bzr8mUiEl8MzRWpVQ3_59eFxKk0EWZ3ca-4IEcpGLkk'
    );
    const uid = localStorage.getItem('uid');
  </script>
  <style>
        /* Neon Theme Colors (dapat disesuaikan untuk tema Zeus) */
        :root {
            --zeus-bg-dark: #1a0f30; /* Darker purple/blue for background */
            --zeus-bg-light: #3a1f60; /* Lighter purple */
            --zeus-gold: #FFD700; /* Gold color */
            --zeus-blue: #00BFFF; /* Deep Sky Blue */
            --zeus-purple: #8A2BE2; /* Blue Violet */
            --zeus-red: #DC143C; /* Crimson */
            --text-primary: #f0f0f0;
            --text-secondary: #cccccc;
            --border-glow-gold: #FFD700;
            --button-primary: linear-gradient(45deg, #00BFFF, #8A2BE2);
            --button-hover: linear-gradient(45deg, #8A2BE2, #00BFFF);
            --glow-sm: 0 0 5px;
            --glow-md: 0 0 10px;
            --glow-lg: 0 0 20px;
        }

       body {
            font-family: 'Share Tech Mono', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Mengatur konten ke atas */
            min-height: 100vh;
            background-image: url('https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/zaus//images%20(3).jpeg'); /* Menggunakan BG Zeus */
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            color: var(--text-primary);
            margin: 0;
            padding: 10px;
            overflow: hidden;
            box-sizing: border-box;
        }

    h1 {
      background: linear-gradient(45deg, var(--zeus-gold), var(--zeus-blue), var(--zeus-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-size: 2em;
      margin-top: 10px;
      margin-bottom: 15px;
      text-shadow: var(--glow-md) var(--zeus-gold);
      text-align: center;
      padding: 5px 15px;
      border: 2px solid var(--zeus-purple);
      border-radius: 12px;
      box-shadow: var(--glow-md) var(--zeus-blue);
      animation: zeusPulse 2s infinite alternate;
      letter-spacing: 1px;
    }

    @keyframes zeusPulse {
      0% { box-shadow: var(--glow-md) var(--zeus-blue); }
      100% { box-shadow: var(--glow-md) var(--zeus-purple); }
    }

    hr {
      border: none;
      border-top: 1px dashed var(--zeus-gold);
      margin-top: 8px;
    }

    .slot-frame {
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 15px;
      box-shadow: var(--glow-md) var(--zeus-blue);
      border: 2px solid var(--zeus-purple);
      position: relative;
      overflow: hidden; /* Penting untuk animasi jatuh */
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .slot-grid {
      display: grid;
      /* Mahjong Ways grid is typically 5x4 or 5x5. */
      grid-template-columns: repeat(5, min(80px, 15vw));
      grid-template-rows: repeat(4, min(80px, 15vw)); /* Sesuaikan dengan grid Mahjong Anda (biasanya 4 atau 5 baris) */
      gap: 5px;
      justify-content: center;
      border: 0px solid var(--zeus-gold);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: inset 0 0 10px rgba(0,191,255,0.3); /* Blue glow inside */
      position: relative;
    }

    .tile {
      background: #222;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: min(35px, 7vw);
      font-weight: bold;
      color: var(--zeus-gold);
      box-shadow: inset 0 0 3px rgba(255, 215, 0, 0.2), 0 0 5px rgba(255, 215, 0, 0.3);
      transition: transform 0.1s linear, box-shadow 0.3s ease;
      overflow: hidden;
      border: 1px solid rgba(255, 215, 0, 0.3);
      position: relative;
      /* Animasi Jatuh */
      transform: translateY(0);
      transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.4, 1.2), opacity 0.3s ease-out; /* Tambah opacity transition */
      z-index: 1;
    }

    .tile.falling {
        transition: none;
        transform: translateY(-100vh);
    }

    .tile img {
      max-width: 90%;
      max-height: 90%;
      object-fit: contain;
      display: block;
      /* Filter untuk gambar Mahjong, bisa disesuaikan agar sesuai dengan tema Zeus */
      filter: drop-shadow(0 0 5px rgba(0, 191, 255, 0.5));
    }

    /* Animasi pecah */
    .tile.break {
      animation: breakAnim 0.9s forwards;
      z-index: 2;
    }
    @keyframes breakAnim {
      0% { transform: scale(1); opacity: 1; border-color: var(--zeus-red); }
      100% { transform: scale(0.1); opacity: 0; }
    }

    /* --- CSS BARU/MODIFIKASI UNTUK FITUR WILD DAN ANIMASI PECAN --- */

    /* Simbol reguler yang memiliki Wild tersembunyi (latar belakang emas) */
    .tile.hidden-wild-potential {
      background-color: rgba(255, 215, 0, 0.3); /* Latar belakang semi-transparan keemasan */
      border: 2px solid var(--zeus-gold);
      box-shadow: inset 0 0 8px rgba(255, 215, 0, 0.7); /* Cahaya keemasan di dalam */
      animation: pulsePotentialWild 1.5s infinite alternate;
    }

    /* Animasi pulse untuk simbol yang berpotensi wild */
    @keyframes pulsePotentialWild {
      0% { box-shadow: inset 0 0 8px rgba(255, 215, 0, 0.7); }
      100% { box-shadow: inset 0 0 15px rgba(255, 215, 0, 1); }
    }

    /* Efek perubahan bingkai sebelum pecah */
    .tile.pre-break-flash {
        animation: preBreakFlash 0.3s forwards; /* Durasi flash 0.3s */
        border-color: var(--zeus-red) !important; /* Paksa warna merah */
        box-shadow: 0 0 10px var(--zeus-red), inset 0 0 5px var(--zeus-red) !important;
    }

    @keyframes preBreakFlash {
        0% { border-color: var(--zeus-gold); box-shadow: var(--glow-sm) var(--zeus-gold); } /* Warna awal */
        50% { border-color: var(--zeus-red); box-shadow: var(--glow-md) var(--zeus-red); } /* Warna merah di tengah */
        100% { border-color: var(--zeus-gold); box-shadow: var(--glow-sm) var(--zeus-gold); } /* Kembali ke warna awal sebelum pecah */
    }

    /* Animasi saat simbol berubah menjadi Wild */
    .tile.wild-transform {
        animation: wildTransform 0.5s forwards ease-out;
    }

    @keyframes wildTransform {
        0% { transform: scale(1); opacity: 1; filter: grayscale(100%); }
        50% { transform: scale(1.2); opacity: 0.5; filter: grayscale(0%); }
        100% { transform: scale(1); opacity: 1; }
    }

    /* --- AKHIR CSS BARU/MODIFIKASI --- */

    .popup {
      position: fixed;
      top: 80%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: var(--zeus-gold);
      padding: 15px 25px;
      border: 2px solid var(--zeus-gold);
      border-radius: 10px;
      font-size: 1.2em;
      box-shadow: var(--glow-md) var(--zeus-gold);
      z-index: 9999;
      display: none;
      text-align: center;
      text-transform: uppercase;
      font-weight: 600;
    }

    .controls-container {
        width: 100%;
        max-width: 500px;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-around;
        align-items: center;
        margin-top: 15px;
        padding: 0 10px;
        box-sizing: border-box;
    }

    .info-box {
        background-color: var(--zeus-bg-dark);
        border-radius: 10px;
        box-shadow: 0 0 15px var(--border-glow-gold), inset 0 0 5px var(--border-glow-gold);
        padding: 8px 15px;
        text-align: center;
        font-size: 0.9em;
        color: var(--text-primary);
        border: 2px solid var(--zeus-blue);
        margin: 5px;
        flex-grow: 1;
        white-space: nowrap;
    }
    .info-box.balance-box { border-color: var(--zeus-gold); color: var(--zeus-gold); }
    .info-box.bet-box { border-color: var(--zeus-purple); color: var(--zeus-purple); }
    .info-box.freespin-box { border-color: var(--zeus-red); color: var(--zeus-red); }

    .multiplier {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.9);
      padding: 8px 15px;
      border-radius: 15px;
      color: var(--zeus-gold);
      font-size: 2em;
      font-weight: bold;
      border: 3px solid var(--zeus-gold);
      box-shadow: var(--glow-sm) var(--zeus-gold);
      transition: transform 0.2s ease-out;
      z-index: 5;
    }

    .multiplier.zoom {
      animation: multiplierZoom 0.3s ease forwards;
    }

    @keyframes multiplierZoom {
      0% { transform: scale(1); }
      50% { transform: scale(1.5); text-shadow: var(--glow-md) var(--zeus-gold); }
      100% { transform: scale(1); }
    }

    .spin-button {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--zeus-red);
      border: 3px solid var(--zeus-gold);
      border-radius: 50%;
      width: 80px;
      height: 80px;
      font-size: 1.1em;
      font-weight: bold;
      color: #FFF;
      text-shadow: 0 0 8px #FFF, 0 0 15px var(--zeus-gold);
      box-shadow: var(--glow-md) var(--zeus-red);
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 20;
    }

    .spin-button:hover {
      transform: translateX(-50%) scale(1.05);
      box-shadow: var(--glow-md) var(--zeus-blue), var(--glow-md) var(--zeus-gold);
      background: linear-gradient(45deg, var(--zeus-red), var(--zeus-purple));
    }

    .spin-button:active {
      transform: translateX(-50%) scale(0.95);
      box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.5);
    }

    .spin-button:disabled {
      background: #555;
      border-color: #888;
      color: #AAA;
      box-shadow: none;
      cursor: not-allowed;
    }

    .bet-buttons-container {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 10px;
        width: 100%;
        max-width: 400px;
    }

    .bet-buttons-container button {
      padding: 8px 18px;
      background: rgba(0, 0, 0, 0.7);
      color: var(--zeus-blue);
      border: 2px solid var(--zeus-blue);
      border-radius: 25px;
      font-size: 0.9em;
      font-weight: bold;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow: 0 0 8px rgba(0, 0, 255, 0.3);
      transition: all 0.2s ease;
    }

    .bet-buttons-container button:hover {
      background: rgba(0, 0, 0, 0.9);
      box-shadow: var(--glow-md) var(--zeus-blue);
    }

    .bet-buttons-container button:active {
      transform: scale(0.97);
    }

    /* Specific bet button colors */
    #betMinus { border-color: var(--zeus-purple); color: var(--zeus-purple); }
    #betPlus { border-color: var(--zeus-red); color: var(--zeus-red); }
    #minBetBtn, #maxBetBtn { border-color: var(--zeus-gold); color: var(--zeus-gold); }

    /* Special Symbol styling (Mahjong Wild/Scatter/Gold Tile) */
    .tile.wild-symbol { /* For Mahjong Wild (e.g., golden tile) */
      border: 2px solid var(--zeus-gold);
      box-shadow: 0 0 10px var(--zeus-gold), inset 0 0 5px var(--zeus-gold);
      animation: pulseSpecial 1.2s infinite alternate;
    }

    @keyframes pulseSpecial {
      0% { transform: scale(1); box-shadow: 0 0 10px var(--zeus-gold), inset 0 0 5px var(--zeus-gold); }
      50% { transform: scale(1.02); box-shadow: 0 0 18px var(--zeus-gold), inset 0 0 8px var(--zeus-gold); }
      100% { transform: scale(1); box-shadow: 0 0 10px var(--zeus-gold), inset 0 0 5px var(--zeus-gold); }
    }

    .tile.scatter-symbol { /* For Mahjong Scatter (e.g., logo) */
      border: 2px solid var(--zeus-blue);
      box-shadow: 0 0 10px var(--zeus-blue), inset 0 0 5px var(--zeus-blue);
      animation: pulseScatter 1.2s infinite alternate;
    }

    @keyframes pulseScatter {
      0% { transform: scale(1); box-shadow: 0 0 10px var(--zeus-blue), inset 0 0 5px var(--zeus-blue); }
      50% { transform: scale(1.02); box-shadow: 0 0 18px var(--zeus-blue), inset 0 0 8px var(--zeus-blue); }
      100% { transform: scale(1); box-shadow: 0 0 10px var(--zeus-blue), inset 0 0 5px var(--zeus-blue); }
    }

    /* Win Animation Overlay */
    .win-animation-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.4s ease, visibility 0.4s ease;
    }

    .win-animation-content {
        background: linear-gradient(45deg, var(--zeus-gold), var(--zeus-blue), var(--zeus-purple));
        padding: 30px 40px;
        border-radius: 20px;
        box-shadow: var(--glow-lg) var(--zeus-gold);
        text-align: center;
        transform: scale(0.7);
        opacity: 0;
        animation: winPopIn 0.8s forwards ease-out;
        border: 3px solid var(--zeus-gold);
    }

    @keyframes winPopIn {
        0% { transform: scale(0.5); opacity: 0; }
        70% { transform: scale(1.05); opacity: 1; }
        100% { transform: scale(1); opacity: 1; }
    }

    .win-animation-content h2 {
        font-size: 2.5em;
        color: #FFF;
        margin-bottom: 15px;
        text-shadow: var(--glow-md) var(--zeus-red);
        text-transform: uppercase;
        letter-spacing: 2px;
        font-weight: 800;
    }

    .win-animation-content p {
        font-size: 2em;
        color: var(--zeus-gold);
        font-weight: bold;
        text-shadow: var(--glow-md) var(--zeus-gold);
        letter-spacing: 1px;
    }

    marquee {
        width: 100%;
        background: rgba(0, 0, 0, 0.5);
        color: var(--zeus-gold);
        padding: 5px 0;
        margin-bottom: 10px;
        font-size: 0.9em;
        border-top: 1px solid var(--zeus-gold);
        border-bottom: 1px solid var(--zeus-gold);
        box-shadow: 0 0 10px rgba(255,215,0,0.3);
    }

    /* Media queries untuk responsivitas */
    @media (max-width: 768px) {
        body { padding: 5px; }
        h1 { font-size: 1.5em; margin-bottom: 10px; }
        .slot-frame { padding: 5px; }
        .slot-grid {
            grid-template-columns: repeat(5, min(50px, 15vw)); /* Sesuaikan untuk Mahjong 5x4 */
            grid-template-rows: repeat(4, min(50px, 15vw));
            gap: 2px;
        }
        .tile { font-size: min(25px, 6vw); border-radius: 4px; }
        .tile img { max-width: 80%; max-height: 80%; }
        .multiplier { font-size: 1.5em; padding: 5px 10px; top: 5px; right: 5px; }
        .spin-button { width: 60px; height: 60px; font-size: 0.9em; bottom: 10px; }
        .bet-buttons-container button { padding: 6px 12px; font-size: 0.8em; border-radius: 20px; }
        .info-box { font-size: 0.8em; padding: 6px 10px; margin: 3px; }
        .win-animation-content h2 { font-size: 1.8em; }
        .win-animation-content p { font-size: 1.5em; }
    }

  </style>
  </head>
  <body>
  <audio id="rollSound" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//mixkit-fast-sci-fi-sweep-1946.mp3"></audio>
  <audio id="winSmallSound" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//mixkit-money-bag-drop-1989.mp3"></audio>
  <audio id="winBigSound" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//mixkit-final-level-bonus-2061.mp3"></audio>
  <audio id="breakSound" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//mixkit-mechanical-crate-pick-up-3154%20(1).mp3"></audio>
  <div id="popup" class="popup"></div>
  <audio id="spinSound" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//mixkit-game-ball-tap-2073.mp3"></audio>
  <audio id="bgm" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//dj-background-music-background-music-free-music-music-free-for-use-221916%20(1).mp3" loop></audio>
  <audio id="freeSpinSound" src="https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/music//mixkit-game-level-completed-2059.mp3"></audio>
  <audio id="freeSpinBGM" src="https://www.bensound.com/bensound-music/bensound-epic.mp3" loop></audio>
  <marquee>â€¢SELAMAT DATANG DI MAHJONG WAYS!â€¢KUMPULKAN SIMBOL EMAS UNTUK KEMENANGAN BESAR!â€¢</marquee>

  <h1>Mahjong Ways<hr></h1>
  <div class="slot-frame">
    <div class="slot-grid" id="grid"></div>
    <div class="multiplier" id="multiplierDisplay">x1</div>
  </div>

  <div class="controls-container">
    <div class="info-box balance-box" id="balanceDisplay">Saldo: Rp0</div>
    <div class="info-box bet-box" id="betDisplay">BET: 100</div>
    <div class="info-box freespin-box" id="freeSpinDisplay">Free Spins: 0</div>
  </div>

  <div class="bet-buttons-container">
    <button id="minBetBtn">MIN</button>
    <button id="betMinus">-</button>
    <button id="betPlus">+</button>
    <button id="maxBetBtn">MAX</button>
  </div>

  <button class="spin-button" id="spinButton">SPIN</button>

  <div id="freeSpinWinOverlay" class="win-animation-overlay">
    <div class="win-animation-content">
      <h2>FREE SPIN SELESAI!</h2>
      <p>TOTAL KEMENANGAN: <span id="freeSpinTotalWin">Rp0</span></p>
    </div>
  </div>

  <script>
    const grid = document.getElementById('grid');
    const spinButton = document.getElementById('spinButton');
    const balanceDisplay = document.getElementById('balanceDisplay');
    const betDisplay = document.getElementById('betDisplay');
    const multiplierDisplay = document.getElementById('multiplierDisplay');
    const rollSound = document.getElementById('rollSound');
    const winSmallSound = document.getElementById('winSmallSound');
    const winBigSound = document.getElementById('winBigSound');
    const betMinusBtn = document.getElementById('betMinus');
    const betPlusBtn = document.getElementById('betPlus');
    const freeSpinDisplay = document.getElementById('freeSpinDisplay');
    const freeSpinWinOverlay = document.getElementById('freeSpinWinOverlay');
    const freeSpinTotalWinDisplay = document.getElementById('freeSpinTotalWin');


    const symbolPayouts = {
      'ðŸ¦§': 15,
      'ðŸ…': 13,
      'ðŸ¦«': 12,
      'ðŸ¥': 11,
      'ðŸ¦œ': 10,
      'ðŸ“': 9,
      'ðŸ•Šï¸': 6,
      'ðŸ–': 4,
      'ðŸ¦•': 7,
      'ðŸˆ': 6,
      'ðŸ¬': 5,
    };

    const width = 5;
    const height = 4;
    // Hapus WILD_SYMBOL dan SCATTER_SYMBOL dari array symbols yang reguler, karena dia hanya akan muncul setelah transformasi atau punya fungsi khusus
    const regularSymbols = ['ðŸ¬', 'ðŸˆ', 'ðŸ¦•', 'ðŸ–', 'ðŸ•Šï¸', 'ðŸ“', 'ðŸ¦œ', 'ðŸ¥', 'ðŸ¦«', 'ðŸ…', 'ðŸ¦§'];
    const WILD_SYMBOL = 'ðŸŒŸ'; // Simbol Wild yang sebenarnya
    const SCATTER_SYMBOL = 'ðŸ‰';

    let currentSymbols = []; // Simbol yang terlihat di grid
    let hiddenWildStatus = []; // Boolean array: true jika ada wild tersembunyi
    let balance = 0;
    let bet = 100;
    const minBet = 100;
    const maxBet = 1000;
    let multiplier = 0;
    let freeSpinCount = 0;
    let totalFreeSpinWin = 0; // Tambahkan variabel untuk total kemenangan Free Spin

    // AUDIO BARU DAN VARIABEL FLAG
    const bgm = document.getElementById('bgm');
    const freeSpinSound = document.getElementById('freeSpinSound');
    const freeSpinBGM = document.getElementById('freeSpinBGM');
    const breakSound = document.getElementById('breakSound'); // Dapatkan elemen audio breakSound
    let isInFreeSpinMode = false; // Flag untuk melacak status mode Free Spin


async function loadSaldo() {
Â  if (!uid) {
Â  Â  alert("User belum login!");
Â  Â  window.location.href = "index.html"; // redirect ke login kalau belum login
Â  Â  return;
Â  }

Â  const { data, error } = await supabase
Â  Â  .from('users_data')
Â  Â  .select('saldo')
Â  Â  .eq('user_id', uid)
Â  Â  .single();

Â  if (error || !data) {
Â  Â  alert("Gagal mengambil saldo user!");
Â  Â  return;
Â  }

Â  balance = data.saldo;
Â  updateBalance(0);
}

window.onload = () => {
Â  loadSaldo();
Â  init(); // jalankan game
};

    // --- MODIFIKASI: generateRandomSymbols untuk hidden wild dan scatter ---
    function generateRandomSymbols() {
      const symbolsArr = [];
      const hiddenWildArr = []; // Untuk melacak wild tersembunyi
      for (let i = 0; i < width * height; i++) {
        let symbolToShow;
        let isHiddenWild = false;
        const col = i % width;

        const rand = Math.random();

        // Probabilitas Scatter (misal 1% dari total simbol)
        const SCATTER_PROB = 0.01;
        // Probabilitas Wild tersembunyi (misal 10% di kolom tengah, 5% di kolom tepi)
        // Wild hanya bisa muncul di kolom 2,3,4 (indeks 1,2,3)
        const HIDDEN_WILD_PROB_MIDDLE = 0.10; // Kolom 1,2,3 (indeks 1,2,3)
        const HIDDEN_WILD_PROB_EDGE = 0.05; // Kolom 0,4 (indeks 0,4)

        // PRIORITAS: Scatter > Hidden Wild > Regular
        if (rand < SCATTER_PROB) {
            symbolToShow = SCATTER_SYMBOL;
        } else {
            // Wild tersembunyi hanya di kolom 1,2,3
            const wildProb = (col > 0 && col < width - 1) ? HIDDEN_WILD_PROB_MIDDLE : HIDDEN_WILD_PROB_EDGE; // kol 1,2,3 -> tengah; kol 0,4 -> tepi
            if (rand < (SCATTER_PROB + wildProb) && (col > 0 && col < width - 1)) { // Wild tersembunyi hanya di kolom 1,2,3
                symbolToShow = regularSymbols[Math.floor(Math.random() * regularSymbols.length)];
                isHiddenWild = true;
            } else {
                symbolToShow = regularSymbols[Math.floor(Math.random() * regularSymbols.length)];
            }
        }
        symbolsArr.push(symbolToShow);
        hiddenWildArr.push(isHiddenWild);
      }
      return { symbols: symbolsArr, hiddenWilds: hiddenWildArr };
    }

    // --- MODIFIKASI: renderGrid untuk hidden wild dan actual wild ---
    // Fungsi ini bertanggung jawab untuk merender ULANG SELURUH grid
    function renderGrid(symbolsArr) {
        grid.innerHTML = ''; // KOSONGKAN grid untuk render ulang penuh
        symbolsArr.forEach((sym, i) => {
            const div = document.createElement('div');
            div.className = 'tile'; // Setiap tile dimulai dengan kelas dasar 'tile'

            // Hapus semua kelas khusus yang mungkin ada dari rendering sebelumnya (jika ini bukan render penuh)
            // Meskipun grid.innerHTML = '' sudah menghapus semua, ini adalah praktik yang baik.
            div.classList.remove('wild-symbol', 'scatter-symbol', 'hidden-wild-potential', 'break', 'pre-break-flash', 'wild-transform');

            // Logika untuk menampilkan simbol atau gambar
            if (sym === WILD_SYMBOL) {
                const img = document.createElement('img');
                img.src = 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/zaus//wild.simbol.mahjhong.png';
                img.alt = 'Wild';
                div.appendChild(img);
                div.classList.add('wild-symbol');
            } else if (sym === SCATTER_SYMBOL) {
                const img = document.createElement('img');
                img.src = 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/zaus//naga-mahjong%20(1).png'; // URL Scatter Anda
                img.alt = 'Scatter';
                div.appendChild(img);
                div.classList.add('scatter-symbol'); // Tambahkan kelas untuk styling Scatter
            } else {
                div.textContent = sym; // Jika bukan Wild atau Scatter, tampilkan teks simbol
                if (hiddenWildStatus[i]) {
                    div.classList.add('hidden-wild-potential'); // Tambahkan kelas jika ini hidden wild
                }
            }
            grid.appendChild(div);
        });
    }

    // --- MODIFIKASI: animateReelShake (penting untuk mengisi ulang) ---
    // Fungsi ini bertanggung jawab untuk animasi dan pembaruan simbol PER REEL
    function animateReelShake(col) {
      return new Promise(resolve => {
        const reelSymbols = [];
        const reelHiddenWildStatus = [];
        for (let row = 0; row < height; row++) {
          reelSymbols.push(currentSymbols[row * width + col]);
          reelHiddenWildStatus.push(hiddenWildStatus[row * width + col]);
        }

        const reelTiles = [];
        for (let row = 0; row < height; row++) {
          reelTiles.push(grid.children[row * width + col]);
        }

        let position = 1;
        const tileHeight = 10; // Ini adalah nilai arbitrer, bukan tinggi piksel sebenarnya
        const totalScrolls = 10 + col * 5; // Lebih banyak gulungan untuk kolom kanan
        let scrollCount = 0;

        const rollSoundInstance = new Audio(rollSound.src);
        rollSoundInstance.volume = 0.5;
        rollSoundInstance.play();

        function step() {
          position += 5; // Gerakkan visual gulungan
          if (position >= tileHeight) { // Jika "melampaui" satu tile
            position -= tileHeight; // Reset posisi
            scrollCount++; // Hitung gulungan

            let newSymbolToShow;
            let newIsHiddenWild = false;
            const rand = Math.random();

            const SCATTER_PROB = 0.01;
            const HIDDEN_WILD_PROB_MIDDLE = 0.10;
            const HIDDEN_WILD_PROB_EDGE = 0.05;

            // PRIORITAS: Scatter > Hidden Wild > Regular
            if (rand < SCATTER_PROB) {
                newSymbolToShow = SCATTER_SYMBOL;
            } else {
                // Wild tersembunyi hanya di kolom 1,2,3
                const wildProb = (col > 0 && col < width - 1) ? HIDDEN_WILD_PROB_MIDDLE : HIDDEN_WILD_PROB_EDGE;
                if (rand < (SCATTER_PROB + wildProb) && (col > 0 && col < width - 1)) { // Wild tersembunyi hanya di kolom 1,2,3
                    newSymbolToShow = regularSymbols[Math.floor(Math.random() * regularSymbols.length)];
                    newIsHiddenWild = true;
                } else {
                    newSymbolToShow = regularSymbols[Math.floor(Math.random() * regularSymbols.length)];
                }
            }

            // Geser simbol ke bawah, tambahkan simbol baru di atas
            reelSymbols.unshift(newSymbolToShow);
            reelHiddenWildStatus.unshift(newIsHiddenWild);
            reelSymbols.pop();
            reelHiddenWildStatus.pop();

            // Perbarui tampilan setiap tile di reel ini
            for (let r = 0; r < height; r++) {
              const currentTile = reelTiles[r];
              currentTile.innerHTML = ''; // KOSONGKAN innerHTML untuk memastikan tidak ada sisa teks/gambar
              currentTile.classList.remove('wild-symbol', 'scatter-symbol', 'hidden-wild-potential'); // Hapus semua kelas khusus yang mungkin ada

              if (reelSymbols[r] === WILD_SYMBOL) {
                const img = document.createElement('img');
                img.src = 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/zaus//wild.simbol.mahjhong.png';
                img.alt = 'Wild';
                currentTile.appendChild(img);
                currentTile.classList.add('wild-symbol');
              } else if (reelSymbols[r] === SCATTER_SYMBOL) {
                const img = document.createElement('img');
                img.src = 'https://vqmfachxnjyxwuavpgds.supabase.co/storage/v1/object/public/zaus//naga-mahjong%20(1).png'; // URL Scatter Anda
                img.alt = 'Scatter';
                currentTile.appendChild(img);
                currentTile.classList.add('scatter-symbol'); // Tambahkan kelas untuk styling Scatter
              } else {
                currentTile.textContent = reelSymbols[r];
                if (reelHiddenWildStatus[r]) {
                    currentTile.classList.add('hidden-wild-potential');
                }
              }
            }
          }

          if (scrollCount >= totalScrolls) {
            // Animasi selesai, reset transformasi
            for (let r = 0; r < height; r++) {
              reelTiles[r].style.transform = 'translateY(0)';
            }
            rollSoundInstance.pause();
            rollSoundInstance.currentTime = 0;

            // Update simbol global setelah gulungan berhenti
            for (let r = 0; r < height; r++) {
              currentSymbols[r * width + col] = reelSymbols[r];
              hiddenWildStatus[r * width + col] = reelHiddenWildStatus[r];
            }
            resolve(); // Selesaikan Promise
          } else {
            requestAnimationFrame(step); // Lanjutkan animasi
          }
        }
        step();
      });
    }

    // --- getWinningTiles: DIPERBAIKI (Penanganan Scatter Lebih Ketat) ---
    function getWinningTiles(symbolsArr) {
        const winningTiles = new Set();
        const scatterTiles = new Set();
        let currentRoundWin = 0;

        // Kumpulkan semua Scatter terlebih dahulu. Scatter HANYA dikumpulkan, TIDAK dipecah di sini.
        for (let i = 0; i < symbolsArr.length; i++) {
            if (symbolsArr[i] === SCATTER_SYMBOL) {
                scatterTiles.add(i);
            }
        }

        // Cek kombinasi kemenangan untuk simbol reguler dan Wild
        for (const targetSymbol of regularSymbols) {
            let winningPaths = [];
            let firstReelMatches = [];
            for (let row = 0; row < height; row++) {
                const index = row * width + 0;
                const symbolInReel = symbolsArr[index];
                // PENTING: Pastikan hanya targetSymbol atau WILD_SYMBOL yang cocok di reel pertama, BUKAN SCATTER
                if ((symbolInReel === targetSymbol || symbolInReel === WILD_SYMBOL) && symbolInReel !== SCATTER_SYMBOL) {
                    firstReelMatches.push({ index: index, symbol: symbolInReel, path: [index] });
                }
            }

            if (firstReelMatches.length === 0) continue;

            function findPaths(currentMatches, currentReel) {
                if (currentReel === width) {
                    winningPaths.push(currentMatches);
                    return;
                }

                let nextReelMatches = [];
                for (const match of currentMatches) {
                    for (let row = 0; row < height; row++) {
                        const index = row * width + currentReel;
                        const symbolInNextReel = symbolsArr[index];
                        // PERBAIKAN KRITIS: Pastikan simbol di reel berikutnya cocok dengan targetSymbol ATAU WILD_SYMBOL,
                        // dan yang terpenting, BUKAN SCATTER_SYMBOL.
                        if ((symbolInNextReel === targetSymbol || symbolInNextReel === WILD_SYMBOL) && symbolInNextReel !== SCATTER_SYMBOL) {
                            nextReelMatches.push({
                                 index: index,
                                symbol: symbolInNextReel,
                                path: [...match.path, index]
                            });
                        }
                    }
                }

                if (nextReelMatches.length > 0) {
                    findPaths(nextReelMatches, currentReel + 1);
                } else if (currentMatches[0].path.length >= 3) {
                    winningPaths.push(currentMatches);
                }
            }

            findPaths(firstReelMatches, 1);

            for (const pathGroup of winningPaths) {
                let maxConsecutiveReels = 0;
                if (pathGroup.length > 0) {
                    maxConsecutiveReels = pathGroup[0].path.length;
                }

                if (maxConsecutiveReels >= 3) {
                    const basePayout = symbolPayouts[targetSymbol] || 1;

                    let waysCount = 1;
                    for (let reelIdx = 0; reelIdx < maxConsecutiveReels; reelIdx++) {
                        let matchingPositionsInReel = 0;
                        for(let row = 0; row < height; row++) {
                            const index = row * width + reelIdx;
                            // Pastikan simbol cocok (targetSymbol atau WILD_SYMBOL)
                            // dan BUKAN SCATTER
                            if ((symbolsArr[index] === targetSymbol || symbolsArr[index] === WILD_SYMBOL) && symbolsArr[index] !== SCATTER_SYMBOL) {
                                matchingPositionsInReel++;
                            }
                        }
                        waysCount *= matchingPositionsInReel;
                    }

                    let lengthPayoutFactor = 0;
                    if (maxConsecutiveReels === 3) lengthPayoutFactor = 1;
                    else if (maxConsecutiveReels === 4) lengthPayoutFactor = 3;
                    else if (maxConsecutiveReels === 5) lengthPayoutFactor = 10;

                    currentRoundWin += (basePayout * lengthPayoutFactor * waysCount * (bet / 100));

                    for (const path of pathGroup) {
                        path.path.forEach(idx => winningTiles.add(idx));
                    }
                }
            }
        }
        return {
            winningTiles: Array.from(winningTiles),
            scatterCount: scatterTiles.size,
            scatterIndices: Array.from(scatterTiles),
            currentRoundWin: currentRoundWin
        };
    }

    // --- animateWinningTiles: Ditambah logic untuk efek flash bingkai ---
    async function animateWinningTiles(indices) {
        const delay = ms => new Promise(res => setTimeout(res, ms));

        // Tahap 1: Beri efek flash pada bingkai
        document.querySelectorAll('.tile').forEach((tile, i) => {
            if (indices.includes(i)) {
                tile.classList.add('pre-break-flash');
            }
        });
        await delay(300); // Tunggu durasi animasi flash

        // Tahap 2: Lanjutkan dengan animasi pecah
        document.querySelectorAll('.tile').forEach((tile, i) => {
            if (indices.includes(i)) {
                tile.classList.remove('pre-break-flash'); // Hapus kelas flash
                tile.classList.add('break');
            }
        });
        // Mainkan suara pecah setiap kali ada simbol yang pecah
        breakSound.currentTime = 0;
        breakSound.play();
    }


    // --- handleTileCollapse: DIPERBAIKI (Penanganan Scatter Lebih Ketat) ---
    async function handleTileCollapse(winningIndices, scatterIndicesForBreak) {
        const delay = ms => new Promise(res => setTimeout(res, ms));

        const allIndicesToBreak = new Set([...winningIndices, ...scatterIndicesForBreak]);

        if (allIndicesToBreak.size > 0) {
            await animateWinningTiles(Array.from(allIndicesToBreak));
            await delay(500); // Durasi animasi pecah
        }

        const transformedWilds = new Set();

        for (let i = 0; i < currentSymbols.length; i++) {
            // Jika simbol ini adalah bagian dari kemenangan reguler yang akan pecah
            if (winningIndices.includes(i)) {
                // Jika itu hidden wild dan pecah, transformasikan. PASTIKAN BUKAN SCATTER!
                if (hiddenWildStatus[i] && currentSymbols[i] !== SCATTER_SYMBOL) {
                    currentSymbols[i] = WILD_SYMBOL; // Simbol berubah menjadi Wild
                    hiddenWildStatus[i] = false; // Tidak lagi menjadi hidden wild
                    transformedWilds.add(i); // Catat sebagai wild yang baru saja bertransformasi
                } else {
                    currentSymbols[i] = null; // Simbol reguler pecah jadi null
                }
            }
            // Jika simbol ini adalah Scatter yang pecah karena memicu Free Spin
            else if (scatterIndicesForBreak.includes(i)) {
                currentSymbols[i] = null; // Scatter pecah jadi null
            }
            // Simbol yang tidak termasuk dalam winningIndices atau scatterIndicesForBreak akan tetap ada
        }

        // Render ulang grid setelah ada simbol yang "pecah" atau bertransformasi
        // Ini mungkin alasan kenapa Scatter terlihat setelah pecah, karena renderGrid dipanggil ulang.
        renderGrid(currentSymbols);

        if (transformedWilds.size > 0) {
            for (const idx of transformedWilds) {
                const tileElement = grid.children[idx];
                if (tileElement) {
                    tileElement.classList.add('wild-transform'); // Animasi transformasi
                    // Hapus kelas hidden-wild-potential jika masih ada
                    tileElement.classList.remove('hidden-wild-potential');
                    // Tambahkan kelas wild-symbol untuk styling normal wild
                    tileElement.classList.add('wild-symbol');
                }
            }
            await delay(500); // Tunggu animasi transformasi selesai
            for (const idx of transformedWilds) {
                 const tileElement = grid.children[idx];
                 if (tileElement) {
                     tileElement.classList.remove('wild-transform'); // Hapus kelas animasi setelah selesai
                 }
            }
        }

        // Tahap 2: Runtuhkan simbol dan isi ulang
        for (let col = 0; col < width; col++) {
            const colSymbols = [];
            const colHiddenWildStatus = [];
            for (let row = height - 1; row >= 0; row--) {
                const idx = row * width + col;
                if (currentSymbols[idx] !== null) {
                    colSymbols.unshift(currentSymbols[idx]);
                    colHiddenWildStatus.unshift(hiddenWildStatus[idx]);
                }
            }

            while (colSymbols.length < height) {
                let newSymbolToShow;
                let newIsHiddenWild = false;
                const rand = Math.random();

                const SCATTER_PROB = 0.01;
                const HIDDEN_WILD_PROB_MIDDLE = 0.10;
                const HIDDEN_WILD_PROB_EDGE = 0.05;

                // PRIORITAS: Scatter > Hidden Wild > Regular
                if (rand < SCATTER_PROB) {
                    newSymbolToShow = SCATTER_SYMBOL;
                } else {
                    // Wild tersembunyi hanya di kolom 1,2,3
                    const wildProb = (col > 0 && col < width - 1) ? HIDDEN_WILD_PROB_MIDDLE : HIDDEN_WILD_PROB_EDGE;
                    if (rand < (SCATTER_PROB + wildProb) && (col > 0 && col < width - 1)) { // Wild tersembunyi hanya di kolom 1,2,3
                        newSymbolToShow = regularSymbols[Math.floor(Math.random() * regularSymbols.length)];
                        newIsHiddenWild = true;
                    } else {
                        newSymbolToShow = regularSymbols[Math.floor(Math.random() * regularSymbols.length)];
                    }
                }
                colSymbols.unshift(newSymbolToShow);
                colHiddenWildStatus.unshift(newIsHiddenWild);
            }

            for (let row = 0; row < height; row++) {
                const globalIndex = row * width + col;
                currentSymbols[globalIndex] = colSymbols[row];
                hiddenWildStatus[globalIndex] = colHiddenWildStatus[row];
            }
        }
        renderGrid(currentSymbols); // Render ulang grid dengan simbol baru dan status wild
    }


    function updateBalance(amount) {
        balance += amount;
        balanceDisplay.textContent = `Saldo: Rp.${balance}`;
    }

    function updateBetDisplay() {
        betDisplay.textContent = `${bet}`;
    }

    function updateFreeSpinDisplay() {
        if (freeSpinCount > 0) {
            freeSpinDisplay.textContent = `Free Spins: ${freeSpinCount}`;
            freeSpinDisplay.style.display = 'block';
        } else {
            freeSpinDisplay.textContent = `Free Spins: 0`;
            freeSpinDisplay.style.display = 'none';
        }
    }

    function showPopup(message) {
        const popup = document.getElementById('popup');
        popup.textContent = message;
        popup.style.display = 'block';
        setTimeout(() => {
            popup.style.display = 'none';
        }, 1500);
    }

    async function showFreeSpinWinAnimation(totalWin) {
        freeSpinTotalWinDisplay.textContent = `Rp.${totalWin}`;
        freeSpinWinOverlay.style.opacity = '1';
        freeSpinWinOverlay.style.visibility = 'visible';

        // Play big win sound for Free Spin total win
        document.getElementById('winBigSound').currentTime = 0;
        document.getElementById('winBigSound').play();

        await new Promise(resolve => setTimeout(resolve, 5000)); // Tampilkan selama 3 detik
        freeSpinWinOverlay.style.opacity = '0';
        freeSpinWinOverlay.style.visibility = 'hidden';
    }


    async function spin() {
        if (freeSpinCount === 0 && balance < bet) {
            showPopup('Saldo tidak cukup!');
            return;
        }

        const spinSound = document.getElementById('spinSound');
        spinSound.currentTime = 0;
        spinSound.play();

        // Jangan mengurangi saldo jika sedang Free Spin
        if (freeSpinCount === 0) {
            updateBalance(-bet);
        } else {
            freeSpinCount--;
        }
        updateFreeSpinDisplay();

        spinButton.disabled = true;

        multiplier = 0;
        multiplierDisplay.textContent = `x${multiplier}`;

        rollSound.currentTime = 0;
        rollSound.play();

        for (let col = 0; col < width; col++) {
            await animateReelShake(col);
        }

        rollSound.pause();
        rollSound.currentTime = 0;

        let currentSpinWin = 0; // Kemenangan untuk spin saat ini
        let chainReaction = true;

        while (chainReaction) {
            chainReaction = false;
            const { winningTiles, scatterCount, scatterIndices, currentRoundWin: baseWin } = getWinningTiles(currentSymbols);

            let roundPayout = baseWin;
            let indicesToBreakInThisRound = Array.from(winningTiles); // Convert Set to Array
            let scatterIndicesToBreak = []; // Ini akan diisi HANYA jika Free Spin terpicu

            // LOGIKA PEMICU FREE SPIN
            if (scatterCount >= 3) {
                let newFreeSpins = 0;
                if (scatterCount === 3) newFreeSpins = 10;
                else if (scatterCount === 4) newFreeSpins = 12;
                else if (scatterCount >= 5) newFreeSpins = 15;

                freeSpinCount += newFreeSpins;
                showPopup(`Anda mendapatkan ${newFreeSpins} Free Spins!`);
                chainReaction = true; // Scatter memicu reaksi berantai, jadi akan ada runtuhan
                updateFreeSpinDisplay();

                // Scatter hanya akan pecah JIKA memicu Free Spin
                scatterIndicesToBreak = scatterIndices; // Tambahkan semua scatter yang memicu ke daftar pecah

                if (newFreeSpins > 0 && !isInFreeSpinMode) {
                    freeSpinSound.currentTime = 0;
                    freeSpinSound.play();
                    bgm.pause();
                    bgm.currentTime = 0;
                    freeSpinBGM.volume = 0.3;
                    freeSpinBGM.play();
                    isInFreeSpinMode = true;
                    totalFreeSpinWin = 0;
                }
            }

            // LOGIKA MULTIPLIER DAN KEMENANGAN GARIS
            if (winningTiles.length > 0) {
                multiplier = Math.min(multiplier + 1, 5);
                multiplierDisplay.textContent = `x${multiplier}`;

                roundPayout *= multiplier; // Terapkan multiplier ke kemenangan putaran ini
                chainReaction = true; // Kemenangan memicu reaksi berantai
            }

            currentSpinWin += roundPayout; // Tambahkan kemenangan putaran ini ke total kemenangan spin

            // Panggil handleTileCollapse dengan dua set indeks terpisah
            // indicesToBreakInThisRound: untuk simbol reguler/wild yang menang dan bisa transform
            // scatterIndicesToBreak: untuk scatter yang pecah karena memicu FS
            if (indicesToBreakInThisRound.length > 0 || scatterIndicesToBreak.length > 0) {
                await handleTileCollapse(indicesToBreakInThisRound, scatterIndicesToBreak);
                await new Promise(res => setTimeout(res, 500)); // Delay untuk jeda antara runtuhan
            } else {
                chainReaction = false; // Jika tidak ada yang pecah atau bertransformasi, hentikan loop
            }
        }

        multiplier = 0;
        multiplierDisplay.textContent = `x${multiplier}`;

        if (isInFreeSpinMode) {
            totalFreeSpinWin += currentSpinWin; // Tambahkan ke total kemenangan Free Spin
        } else {
            updateBalance(currentSpinWin); // Hanya tambahkan ke saldo jika bukan Free Spin
        }

        if (uid) {
            await supabase
                .from('users_data')
                .update({ saldo: balance })
                .eq('user_id', uid);
        }

        if (currentSpinWin > 0) {
            if (currentSpinWin >= bet * 10) {
                document.getElementById('winBigSound').play();
            } else {
                document.getElementById('winSmallSound').play();
            }
            showPopup(`Anda menang Rp.${currentSpinWin}!`);
        } else if (freeSpinCount === 0 && !isInFreeSpinMode) {
             showPopup('Coba lagi!');
        }

        if (freeSpinCount > 0) {
            await new Promise(res => setTimeout(res, 1500));
            spin();
        } else {
            spinButton.disabled = false;
            updateFreeSpinDisplay();
            if (isInFreeSpinMode) {
                freeSpinBGM.pause();
                freeSpinBGM.currentTime = 0;
                bgm.play();
                isInFreeSpinMode = false;
                await showFreeSpinWinAnimation(totalFreeSpinWin);
                updateBalance(totalFreeSpinWin);
                totalFreeSpinWin = 0;
            }
        }
    }

    betMinusBtn.onclick = () => {
      if (bet - 100 >= minBet) {
        bet -= 100;
        updateBetDisplay();
      }
    };
    betPlusBtn.onclick = () => {
      if (bet + 100 <= maxBet) {
          if (freeSpinCount > 0 || (balance >= (bet + 100))) {
                bet += 100;
                updateBetDisplay();
          } else {
              showPopup('Saldo tidak cukup untuk bet ini!');
          }
      }
    };
    spinButton.onclick = spin;

    bgm.volume = 0.3;

    function init() {
      const initialSymbols = generateRandomSymbols();
      currentSymbols = initialSymbols.symbols;
      hiddenWildStatus = initialSymbols.hiddenWilds;
      renderGrid(currentSymbols); // Ini adalah tempat pertama kali Scatter harus dirender
      updateBalance(0);
      updateBetDisplay();
      updateFreeSpinDisplay();

      bgm.play().catch(() => {
        document.body.addEventListener('click', () => {
          bgm.play();
        }, { once: true });
      });
    }

    init();
  </script>
</body>
</html>